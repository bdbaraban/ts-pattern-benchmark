const t=Symbol("@ts-pattern/matcher"),e=Symbol("@ts-pattern/isVariadic"),n="@ts-pattern/anonymous-select-key",r=t=>Boolean(t&&"object"==typeof t),i=e=>e&&!!e[t],s=(n,o,c)=>{if(i(n)){const e=n[t](),{matched:r,selections:i}=e.match(o);return r&&i&&Object.keys(i).forEach(t=>c(t,i[t])),r}if(r(n)){if(!r(o))return!1;if(Array.isArray(n)){if(!Array.isArray(o))return!1;let t=[],r=[],a=[];for(const s of n.keys()){const o=n[s];i(o)&&o[e]?a.push(o):a.length?r.push(o):t.push(o)}if(a.length){if(a.length>1)throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");if(o.length<t.length+r.length)return!1;const e=o.slice(0,t.length),n=0===r.length?[]:o.slice(-r.length),i=o.slice(t.length,0===r.length?Infinity:-r.length);return t.every((t,n)=>s(t,e[n],c))&&r.every((t,e)=>s(t,n[e],c))&&(0===a.length||s(a[0],i,c))}return n.length===o.length&&n.every((t,e)=>s(t,o[e],c))}return Object.keys(n).every(e=>{const r=n[e];return(e in o||i(a=r)&&"optional"===a[t]().matcherType)&&s(r,o[e],c);var a})}return Object.is(o,n)},o=e=>{var n,s,a;return r(e)?i(e)?null!=(n=null==(s=(a=e[t]()).getSelectionKeys)?void 0:s.call(a))?n:[]:Array.isArray(e)?c(e,o):c(Object.values(e),o):[]},c=(t,e)=>t.reduce((t,n)=>t.concat(e(n)),[]);function a(...t){if(1===t.length){const[e]=t;return t=>s(e,t,()=>{})}if(2===t.length){const[e,n]=t;return s(e,n,()=>{})}throw new Error(`isMatching wasn't given the right number of arguments: expected 1 or 2, received ${t.length}.`)}function u(t){return Object.assign(t,{optional:()=>l(t),and:e=>m(t,e),or:e=>y(t,e),select:e=>void 0===e?d(t):d(e,t)})}function h(t){return Object.assign((t=>Object.assign(t,{*[Symbol.iterator](){yield Object.assign(t,{[e]:!0})}}))(t),{optional:()=>h(l(t)),select:e=>h(void 0===e?d(t):d(e,t))})}function l(e){return u({[t]:()=>({match:t=>{let n={};const r=(t,e)=>{n[t]=e};return void 0===t?(o(e).forEach(t=>r(t,void 0)),{matched:!0,selections:n}):{matched:s(e,t,r),selections:n}},getSelectionKeys:()=>o(e),matcherType:"optional"})})}const g=(t,e)=>{for(const n of t)if(!e(n))return!1;return!0},f=(t,e)=>{for(const[n,r]of t.entries())if(!e(r,n))return!1;return!0};function m(...e){return u({[t]:()=>({match:t=>{let n={};const r=(t,e)=>{n[t]=e};return{matched:e.every(e=>s(e,t,r)),selections:n}},getSelectionKeys:()=>c(e,o),matcherType:"and"})})}function y(...e){return u({[t]:()=>({match:t=>{let n={};const r=(t,e)=>{n[t]=e};return c(e,o).forEach(t=>r(t,void 0)),{matched:e.some(e=>s(e,t,r)),selections:n}},getSelectionKeys:()=>c(e,o),matcherType:"or"})})}function p(e){return{[t]:()=>({match:t=>({matched:Boolean(e(t))})})}}function d(...e){const r="string"==typeof e[0]?e[0]:void 0,i=2===e.length?e[1]:"string"==typeof e[0]?void 0:e[0];return u({[t]:()=>({match:t=>{let e={[null!=r?r:n]:t};return{matched:void 0===i||s(i,t,(t,n)=>{e[t]=n}),selections:e}},getSelectionKeys:()=>[null!=r?r:n].concat(void 0===i?[]:o(i))})})}function v(t){return"number"==typeof t}function b(t){return"string"==typeof t}function w(t){return"bigint"==typeof t}const S=u(p(function(t){return!0})),O=S,j=t=>Object.assign(u(t),{startsWith:e=>{return j(m(t,(n=e,p(t=>b(t)&&t.startsWith(n)))));var n},endsWith:e=>{return j(m(t,(n=e,p(t=>b(t)&&t.endsWith(n)))));var n},minLength:e=>j(m(t,(t=>p(e=>b(e)&&e.length>=t))(e))),maxLength:e=>j(m(t,(t=>p(e=>b(e)&&e.length<=t))(e))),includes:e=>{return j(m(t,(n=e,p(t=>b(t)&&t.includes(n)))));var n},regex:e=>{return j(m(t,(n=e,p(t=>b(t)&&Boolean(t.match(n))))));var n}}),B=j(p(b)),E=(t,e)=>p(n=>v(n)&&t<=n&&e>=n),I=t=>p(e=>v(e)&&e<t),K=t=>p(e=>v(e)&&e>t),A=t=>p(e=>v(e)&&e<=t),k=t=>p(e=>v(e)&&e>=t),x=()=>p(t=>v(t)&&Number.isInteger(t)),P=()=>p(t=>v(t)&&Number.isFinite(t)),T=()=>p(t=>v(t)&&t>0),_=()=>p(t=>v(t)&&t<0),W=t=>Object.assign(u(t),{between:(e,n)=>W(m(t,E(e,n))),lt:e=>W(m(t,I(e))),gt:e=>W(m(t,K(e))),lte:e=>W(m(t,A(e))),gte:e=>W(m(t,k(e))),int:()=>W(m(t,x())),finite:()=>W(m(t,P())),positive:()=>W(m(t,T())),negative:()=>W(m(t,_()))}),N=W(p(v)),$=(t,e)=>p(n=>w(n)&&t<=n&&e>=n),z=t=>p(e=>w(e)&&e<t),L=t=>p(e=>w(e)&&e>t),M=t=>p(e=>w(e)&&e<=t),F=t=>p(e=>w(e)&&e>=t),J=()=>p(t=>w(t)&&t>0),U=()=>p(t=>w(t)&&t<0),V=t=>Object.assign(u(t),{between:(e,n)=>V(m(t,$(e,n))),lt:e=>V(m(t,z(e))),gt:e=>V(m(t,L(e))),lte:e=>V(m(t,M(e))),gte:e=>V(m(t,F(e))),positive:()=>V(m(t,J())),negative:()=>V(m(t,U()))}),q=V(p(w)),C=u(p(function(t){return"boolean"==typeof t})),D=u(p(function(t){return"symbol"==typeof t})),G=u(p(function(t){return null==t}));var H={__proto__:null,matcher:t,optional:l,array:function(...e){return h({[t]:()=>({match:t=>{if(!Array.isArray(t))return{matched:!1};if(0===e.length)return{matched:!0};const n=e[0];let r={};if(0===t.length)return o(n).forEach(t=>{r[t]=[]}),{matched:!0,selections:r};const i=(t,e)=>{r[t]=(r[t]||[]).concat([e])};return{matched:t.every(t=>s(n,t,i)),selections:r}},getSelectionKeys:()=>0===e.length?[]:o(e[0])})})},set:function(...e){return u({[t]:()=>({match:t=>{if(!(t instanceof Set))return{matched:!1};let n={};if(0===t.size)return{matched:!0,selections:n};if(0===e.length)return{matched:!0};const r=(t,e)=>{n[t]=(n[t]||[]).concat([e])},i=e[0];return{matched:g(t,t=>s(i,t,r)),selections:n}},getSelectionKeys:()=>0===e.length?[]:o(e[0])})})},map:function(...e){return u({[t]:()=>({match:t=>{if(!(t instanceof Map))return{matched:!1};let n={};if(0===t.size)return{matched:!0,selections:n};const r=(t,e)=>{n[t]=(n[t]||[]).concat([e])};if(0===e.length)return{matched:!0};var i;if(1===e.length)throw new Error(`\`P.map\` wasn't given enough arguments. Expected (key, value), received ${null==(i=e[0])?void 0:i.toString()}`);const[o,c]=e;return{matched:f(t,(t,e)=>{const n=s(o,e,r),i=s(c,t,r);return n&&i}),selections:n}},getSelectionKeys:()=>0===e.length?[]:[...o(e[0]),...o(e[1])]})})},intersection:m,union:y,not:function(e){return u({[t]:()=>({match:t=>({matched:!s(e,t,()=>{})}),getSelectionKeys:()=>[],matcherType:"not"})})},when:p,select:d,any:S,_:O,string:B,between:E,lt:I,gt:K,lte:A,gte:k,int:x,finite:P,positive:T,negative:_,number:N,betweenBigInt:$,ltBigInt:z,gtBigInt:L,lteBigInt:M,gteBigInt:F,positiveBigInt:J,negativeBigInt:U,bigint:q,boolean:C,symbol:D,nullish:G,instanceOf:function(t){return u(p(function(t){return e=>e instanceof t}(t)))},shape:function(t){return u(p(a(t)))}};function Q(t){return new X(t)}const R={matched:!1,value:void 0};class X{constructor(t,e=R){this.input=void 0,this.state=void 0,this.input=t,this.state=e}with(...t){if(this.state.matched)return this;const e=t[t.length-1],r=[t[0]],i=[];3===t.length&&"function"==typeof t[1]?(r.push(t[0]),i.push(t[1])):t.length>2&&r.push(...t.slice(1,t.length-1));let o={};const c=Boolean(r.some(t=>s(t,this.input,(t,e)=>{o[t]=e}))&&i.every(t=>t(this.input)))?{matched:!0,value:e(Object.keys(o).length?n in o?o[n]:o:this.input,this.input)}:R;return new X(this.input,c)}when(t,e){if(this.state.matched)return this;const n=Boolean(t(this.input));return new X(this.input,n?{matched:!0,value:e(this.input,this.input)}:R)}otherwise(t){return this.state.matched?this.state.value:t(this.input)}exhaustive(){return this.run()}run(){if(this.state.matched)return this.state.value;let t;try{t=JSON.stringify(this.input)}catch(e){t=this.input}throw new Error(`Pattern matching error: no pattern matches value ${t}`)}returnType(){return this}}export{H as P,H as Pattern,a as isMatching,Q as match};
//# sourceMappingURL=index.js.map
