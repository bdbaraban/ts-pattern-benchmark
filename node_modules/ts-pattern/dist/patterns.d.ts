import * as symbols from './internals/symbols.js';
import { matcher } from './internals/symbols.js';
import { ExtractPreciseValue } from './types/ExtractPreciseValue.js';
import { Fn } from './types/helpers.js';
import { InvertPattern } from './types/InvertPattern.js';
import { Pattern, UnknownPattern, OptionalP, ArrayP, MapP, SetP, AndP, OrP, NotP, GuardP, SelectP, AnonymousSelectP, GuardExcludeP, CustomP, Matcher } from './types/Pattern.js';
export { Pattern, Fn as unstable_Fn };
export { matcher };
/**
 * @experimental
 * A `Matchable` is an object implementing
 * the Matcher Protocol. It must have a `[P.matcher]: P.Matcher<NarrowFn>`
 * key, which defines how this object should be matched by TS-Pattern.
 *
 * Note that this api is unstable.
 *
 * @example
 * ```ts
 * class Some<T> implements P.unstable_Matchable {
 *  [P.matcher](): P.unstable_Matcher<Some<T>>
 * }
 * ```
 */
export type unstable_Matchable<narrowedOrFn, input = unknown, pattern = never> = CustomP<input, pattern, narrowedOrFn>;
/**
 * @experimental
 * A `Matcher` is an object with `match` function, which
 * defines how this object should be matched by TS-Pattern.
 *
 * Note that this api is unstable.
 *
 * @example
 * ```ts
 * class Some<T> implements P.unstable_Matchable {
 *  [P.matcher](): P.unstable_Matcher<Some<T>>
 * }
 * ```
 */
export type unstable_Matcher<narrowedOrFn, input = unknown, pattern = never> = ReturnType<CustomP<input, pattern, narrowedOrFn>[matcher]>;
/**
 * `P.infer<typeof somePattern>` will return the type of the value
 * matched by this pattern.
 *
 * [Read the documentation for `P.infer` on GitHub](https://github.com/gvergnaud/ts-pattern#Pinfer)
 *
 * @example
 * const userPattern = { name: P.string }
 * type User = P.infer<typeof userPattern>
 */
export type infer<p extends Pattern<any>> = InvertPattern<p, unknown>;
export type narrow<i, p extends Pattern<any>> = ExtractPreciseValue<i, InvertPattern<p, i>>;
type Chainable<p, omitted extends string = never> = p & Omit<{
    /**
     * `.optional()` returns a pattern which matches if the
     * key is undefined or if it is defined and the previous pattern matches its value.
     *
     * [Read the documentation for `P.optional` on GitHub](https://github.com/gvergnaud/ts-pattern#Poptional-patterns)
     *
     * @example
     *  match(value)
     *   .with({ greeting: P.string.optional() }, () => 'will match { greeting?: string}')
     */
    optional<input>(): Chainable<OptionalP<input, p>, omitted | 'optional'>;
    /**
     * `pattern.and(pattern)` returns a pattern that matches
     * if the previous pattern and the next one match the input.
     *
     * [Read the documentation for `P.intersection` on GitHub](https://github.com/gvergnaud/ts-pattern#Pintersection-patterns)
     *
     * @example
     *  match(value)
     *   .with(
     *     P.string.and(P.when(isUsername)),
     *     (username) => '...'
     *   )
     */
    and<input, p2 extends Pattern<input>>(pattern: p2): Chainable<AndP<input, [p, p2]>, omitted>;
    /**
     * `pattern.or(pattern)` returns a pattern that matches
     * if **either** the previous pattern or the next one match the input.
     *
     * [Read the documentation for `P.union` on GitHub](https://github.com/gvergnaud/ts-pattern#Punion-patterns)
     *
     * @example
     *  match(value)
     *   .with(
     *     { value: P.string.or(P.number) },
     *     ({ value }) => 'value: number | string'
     *   )
     */
    or<input, p2 extends Pattern<input>>(pattern: p2): Chainable<OrP<input, [p, p2]>, omitted>;
    /**
     * `P.select()` will inject this property into the handler function's arguments.
     *
     * [Read the documentation for `P.select` on GitHub](https://github.com/gvergnaud/ts-pattern#Pselect-patterns)
     *
     * @example
     *  match<{ age: number }>(value)
     *   .with({ age: P.string.select() }, (age) => 'age: number')
     */
    select<input>(): Chainable<SelectP<symbols.anonymousSelectKey, input, p>, omitted | 'select' | 'or' | 'and'>;
    select<input, k extends string>(key: k): Chainable<SelectP<k, input, p>, omitted | 'select' | 'or' | 'and'>;
}, omitted>;
type Variadic<p> = p & Iterable<p>;
type ArrayChainable<p, omitted extends string = never> = Variadic<p> & Omit<{
    /**
     * `.optional()` returns a pattern which matches if the
     * key is undefined or if it is defined and the previous pattern matches its value.
     *
     * [Read the documentation for `P.optional` on GitHub](https://github.com/gvergnaud/ts-pattern#Poptional-patterns)
     *
     * @example
     *  match(value)
     *   .with({ greeting: P.string.optional() }, () => 'will match { greeting?: string}')
     */
    optional<input>(): ArrayChainable<OptionalP<input, p>, omitted | 'optional'>;
    /**
     * `P.select()` will inject this property into the handler function's arguments.
     *
     * [Read the documentation for `P.select` on GitHub](https://github.com/gvergnaud/ts-pattern#Pselect-patterns)
     *
     * @example
     *  match<{ age: number }>(value)
     *   .with({ age: P.string.select() }, (age) => 'age: number')
     */
    select<input>(): ArrayChainable<SelectP<symbols.anonymousSelectKey, input, p>, omitted | 'select'>;
    select<input, k extends string>(key: k): ArrayChainable<SelectP<k, input, p>, omitted | 'select'>;
}, omitted>;
/**
 * `P.optional(subpattern)` takes a sub pattern and returns a pattern which matches if the
 * key is undefined or if it is defined and the sub pattern matches its value.
 *
 * [Read the documentation for `P.optional` on GitHub](https://github.com/gvergnaud/ts-pattern#Poptional-patterns)
 *
 * @example
 *  match(value)
 *   .with({ greeting: P.optional('Hello') }, () => 'will match { greeting?: "Hello" }')
 */
export declare function optional<input, const p extends unknown extends input ? UnknownPattern : Pattern<input>>(pattern: p): Chainable<OptionalP<input, p>, 'optional'>;
type UnwrapArray<xs> = xs extends readonly (infer x)[] ? x : never;
type UnwrapSet<xs> = xs extends Set<infer x> ? x : never;
type UnwrapMapKey<xs> = xs extends Map<infer k, any> ? k : never;
type UnwrapMapValue<xs> = xs extends Map<any, infer v> ? v : never;
type WithDefault<a, b> = [a] extends [never] ? b : a;
/**
 * `P.array(subpattern)` takes a sub pattern and returns a pattern, which matches
 * arrays if all their elements match the sub pattern.
 *
 * [Read the documentation for `P.array` on GitHub](https://github.com/gvergnaud/ts-pattern#Parray-patterns)
 *
 * @example
 *  match(value)
 *   .with({ users: P.array({ name: P.string }) }, () => 'will match { name: string }[]')
 */
export declare function array<input>(): ArrayChainable<ArrayP<input, unknown>>;
export declare function array<input, const p extends Pattern<WithDefault<UnwrapArray<input>, unknown>>>(pattern: p): ArrayChainable<ArrayP<input, p>>;
/**
 * `P.set(subpattern)` takes a sub pattern and returns a pattern that matches
 * sets if all their elements match the sub pattern.
 *
 * [Read `P.set` documentation on GitHub](https://github.com/gvergnaud/ts-pattern#Pset-patterns)
 *
 * @example
 *  match(value)
 *   .with({ users: P.set(P.string) }, () => 'will match Set<string>')
 */
export declare function set<input>(): Chainable<SetP<input, unknown>>;
export declare function set<input, const p extends Pattern<WithDefault<UnwrapSet<input>, unknown>>>(pattern: p): Chainable<SetP<input, p>>;
/**
 * `P.set(subpattern)` takes a sub pattern and returns a pattern that matches
 * sets if all their elements match the sub pattern.
 *
 * [Read `P.set` documentation on GitHub](https://github.com/gvergnaud/ts-pattern#Pset-patterns)
 *
 * @example
 *  match(value)
 *   .with({ users: P.set(P.string) }, () => 'will match Set<string>')
 */
export declare function map<input>(): Chainable<MapP<input, unknown, unknown>>;
export declare function map<input, const pkey extends Pattern<WithDefault<UnwrapMapKey<input>, unknown>>, const pvalue extends Pattern<WithDefault<UnwrapMapValue<input>, unknown>>>(patternKey: pkey, patternValue: pvalue): Chainable<MapP<input, pkey, pvalue>>;
/**
 * `P.intersection(...patterns)` returns a pattern which matches
 * only if **every** patterns provided in parameter match the input.
 *
 * [Read the documentation for `P.intersection` on GitHub](https://github.com/gvergnaud/ts-pattern#Pintersection-patterns)
 *
 * @example
 *  match(value)
 *   .with(
 *     {
 *       user: P.intersection(
 *         { firstname: P.string },
 *         { lastname: P.string },
 *         { age: P.when(age => age > 21) }
 *       )
 *     },
 *     ({ user }) => 'will match { firstname: string, lastname: string, age: number } if age > 21'
 *   )
 */
export declare function intersection<input, const ps extends readonly [Pattern<input>, ...Pattern<input>[]]>(...patterns: ps): Chainable<AndP<input, ps>>;
/**
 * `P.union(...patterns)` returns a pattern which matches
 * if **at least one** of the patterns provided in parameter match the input.
 *
 * [Read the documentation for `P.union` on GitHub](https://github.com/gvergnaud/ts-pattern#Punion-patterns)
 *
 * @example
 *  match(value)
 *   .with(
 *     { type: P.union('a', 'b', 'c') },
 *     ({ type }) => 'will match { type: "a" | "b" | "c" }'
 *   )
 */
export declare function union<input, const ps extends readonly [Pattern<input>, ...Pattern<input>[]]>(...patterns: ps): Chainable<OrP<input, ps>>;
/**
 * `P.not(pattern)` returns a pattern which matches if the sub pattern
 * doesn't match.
 *
 * [Read the documentation for `P.not` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnot-patterns)
 *
 * @example
 *  match<{ a: string | number }>(value)
 *   .with({ a: P.not(P.string) }, (x) => 'will match { a: number }'
 *   )
 */
export declare function not<input, const p extends Pattern<input> | UnknownPattern>(pattern: p): Chainable<NotP<input, p>>;
/**
 * `P.when((value) => boolean)` returns a pattern which matches
 * if the predicate returns true for the current input.
 *
 * [Read the documentation for `P.when` on GitHub](https://github.com/gvergnaud/ts-pattern#Pwhen-patterns)
 *
 * @example
 *  match<{ age: number }>(value)
 *   .with({ age: P.when(age => age > 21) }, (x) => 'will match if value.age > 21'
 *   )
 */
export declare function when<input, p extends (value: input) => unknown>(predicate: p): GuardP<input, p extends (value: any) => value is infer narrowed ? narrowed : never>;
export declare function when<input, narrowed extends input, excluded>(predicate: (input: input) => input is narrowed): GuardExcludeP<input, narrowed, excluded>;
/**
 * `P.select()` is a pattern which will always match,
 * and will inject the selected piece of input in the handler function.
 *
 * [Read the documentation for `P.select` on GitHub](https://github.com/gvergnaud/ts-pattern#Pselect-patterns)
 *
 * @example
 *  match<{ age: number }>(value)
 *   .with({ age: P.select() }, (age) => 'age: number'
 *   )
 */
export declare function select(): Chainable<AnonymousSelectP, 'select' | 'or' | 'and'>;
export declare function select<input, const patternOrKey extends string | (unknown extends input ? UnknownPattern : Pattern<input>)>(patternOrKey: patternOrKey): patternOrKey extends string ? Chainable<SelectP<patternOrKey, 'select' | 'or' | 'and'>> : Chainable<SelectP<symbols.anonymousSelectKey, input, patternOrKey>, 'select' | 'or' | 'and'>;
export declare function select<input, const p extends unknown extends input ? UnknownPattern : Pattern<input>, const k extends string>(key: k, pattern: p): Chainable<SelectP<k, input, p>, 'select' | 'or' | 'and'>;
type AnyConstructor = abstract new (...args: any[]) => any;
type AnyPattern = Chainable<GuardP<unknown, unknown>, never>;
type StringPattern = StringChainable<GuardP<unknown, string>, never>;
type NumberPattern = NumberChainable<GuardP<unknown, number>, never>;
type BooleanPattern = Chainable<GuardP<unknown, boolean>, never>;
type BigIntPattern = BigIntChainable<GuardP<unknown, bigint>, never>;
type SymbolPattern = Chainable<GuardP<unknown, symbol>, never>;
type NullishPattern = Chainable<GuardP<unknown, null | undefined>, never>;
/**
 * `P.any` is a wildcard pattern, matching **any value**.
 *
 * [Read the documentation for `P.any` on GitHub](https://github.com/gvergnaud/ts-pattern#P_-wildcard)
 *
 * @example
 *  match(value)
 *   .with(P.any, () => 'will always match')
 */
export declare const any: AnyPattern;
/**
 * `P._` is a wildcard pattern, matching **any value**.
 * It's an alias to `P.any`.
 *
 * [Read the documentation for `P._` on GitHub](https://github.com/gvergnaud/ts-pattern#P_-wildcard)
 *
 * @example
 *  match(value)
 *   .with(P._, () => 'will always match')
 */
export declare const _: AnyPattern;
type MaybeAnd<omitted, input, p1, p2> = [omitted] extends [never] ? p2 : AndP<input, [p1, p2]>;
type StringChainable<p extends Matcher<any, any, any, any, any>, omitted extends string = never> = Chainable<p, omitted> & Omit<{
    /**
     * `P.string.startsWith(start)` is a pattern, matching **strings** starting with `start`.
     *
     * [Read the documentation for `P.string.startsWith` on GitHub](https://github.com/gvergnaud/ts-pattern#PstringstartsWith)
     *
     * @example
     *  match(value)
     *   .with(P.string.startsWith('A'), () => 'value starts with an A')
     */
    startsWith<input, const start extends string>(start: start): StringChainable<MaybeAnd<omitted, input, p, GuardP<input, `${start}${string}`>>, omitted | 'startsWith'>;
    /**
     * `P.string.endsWith(end)` is a pattern, matching **strings** ending with `end`.
     *
     * [Read the documentation for `P.string.endsWith` on GitHub](https://github.com/gvergnaud/ts-pattern#PstringendsWith)
     *
     * @example
     *  match(value)
     *   .with(P.string.endsWith('!'), () => 'value ends with an !')
     */
    endsWith<input, const end extends string>(end: end): StringChainable<MaybeAnd<omitted, input, p, GuardP<input, `${string}${end}`>>, omitted | 'endsWith'>;
    /**
     * `P.string.minLength(min)` is a pattern, matching **strings** with at least `min` characters.
     *
     * [Read the documentation for `P.string.minLength` on GitHub](https://github.com/gvergnaud/ts-pattern#PstringminLength)
     *
     * @example
     *  match(value)
     *   .with(P.string.minLength(10), () => 'string with more length <= 10')
     */
    minLength<input, const min extends number>(min: min): StringChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, string, never>>, omitted | 'minLength'>;
    /**
     * `P.string.maxLength(max)` is a pattern, matching **strings** with at most `max` characters.
     *
     * [Read the documentation for `P.string.maxLength` on GitHub](https://github.com/gvergnaud/ts-pattern#PstringmaxLength)
     *
     * @example
     *  match(value)
     *   .with(P.string.maxLength(10), () => 'string with more length >= 10')
     */
    maxLength<input, const max extends number>(max: max): StringChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, string, never>>, omitted | 'maxLength'>;
    /**
     * `P.string.includes(substr)` is a pattern, matching **strings** containing `substr`.
     *
     * [Read the documentation for `P.string.includes` on GitHub](https://github.com/gvergnaud/ts-pattern#Pstringincludes)
     *
     * @example
     *  match(value)
     *   .with(P.string.includes('http'), () => 'value contains http')
     */
    includes<input, const substr extends string>(substr: substr): StringChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, string, never>>, omitted>;
    /**
     * `P.string.regex(expr)` is a pattern, matching **strings** that `expr` regular expression.
     *
     * [Read the documentation for `P.string.regex` on GitHub](https://github.com/gvergnaud/ts-pattern#Pstringregex)
     *
     * @example
     *  match(value)
     *   .with(P.string.regex(/^https?:\/\//), () => 'url')
     */
    regex<input, const expr extends string | RegExp>(expr: expr): StringChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, string, never>>, omitted>;
}, omitted>;
/**
 * `P.string` is a wildcard pattern, matching any **string**.
 *
 * [Read the documentation for `P.string` on GitHub](https://github.com/gvergnaud/ts-pattern#Pstring-wildcard)
 *
 * @example
 *  match(value)
 *   .with(P.string, () => 'will match on strings')
 */
export declare const string: StringPattern;
/**
 * `P.number.between(min, max)` matches **number** between `min` and `max`,
 * equal to min or equal to max.
 *
 * [Read the documentation for `P.number.between` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberbetween)
 *
 * @example
 *  match(value)
 *   .with(P.number.between(0, 10), () => '0 <= numbers <= 10')
 */
export declare const between: <input, const min extends number, const max extends number>(min: min, max: max) => GuardExcludeP<input, number, never>;
/**
 * `P.number.lt(max)` matches **number** smaller than `max`.
 *
 * [Read the documentation for `P.number.lt` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberlt)
 *
 * @example
 *  match(value)
 *   .with(P.number.lt(10), () => 'numbers < 10')
 */
export declare const lt: <input, const max extends number>(max: max) => GuardExcludeP<input, number, never>;
/**
 * `P.number.gt(min)` matches **number** greater than `min`.
 *
 * [Read the documentation for `P.number.gt` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumbergt)
 *
 * @example
 *  match(value)
 *   .with(P.number.gt(10), () => 'numbers > 10')
 */
export declare const gt: <input, const min extends number>(min: min) => GuardExcludeP<input, number, never>;
/**
 * `P.number.lte(max)` matches **number** smaller than or equal to `max`.
 *
 * [Read the documentation for `P.number.lte` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberlte)
 *
 * @example
 *  match(value)
 *   .with(P.number.lte(10), () => 'numbers <= 10')
 */
export declare const lte: <input, const max extends number>(max: max) => GuardExcludeP<input, number, never>;
/**
 * `P.number.gte(min)` matches **number** greater than or equal to `min`.
 *
 * [Read the documentation for `P.number.gte` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumbergte)
 *
 * @example
 *  match(value)
 *   .with(P.number.gte(10), () => 'numbers >= 10')
 */
export declare const gte: <input, const min extends number>(min: min) => GuardExcludeP<input, number, never>;
/**
 * `P.number.int` matches **integer** numbers.
 *
 * [Read the documentation for `P.number.int` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberint)
 *
 * @example
 *  match(value)
 *   .with(P.number.int, () => 'an integer')
 */
export declare const int: <input>() => GuardExcludeP<input, number, never>;
/**
 * `P.number.finite` matches **finite numbers**.
 *
 * [Read the documentation for `P.number.finite` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberfinite)
 *
 * @example
 *  match(value)
 *   .with(P.number.finite, () => 'not Infinity')
 */
export declare const finite: <input>() => GuardExcludeP<input, number, never>;
/**
 * `P.number.positive` matches **positive** numbers.
 *
 * [Read the documentation for `P.number.positive` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberpositive)
 *
 * @example
 *  match(value)
 *   .with(P.number.positive, () => 'number > 0')
 */
export declare const positive: <input>() => GuardExcludeP<input, number, never>;
/**
 * `P.number.negative` matches **negative** numbers.
 *
 * [Read the documentation for `P.number.negative` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumbernegative)
 *
 * @example
 *  match(value)
 *   .with(P.number.negative, () => 'number < 0')
 */
export declare const negative: <input>() => GuardExcludeP<input, number, never>;
type NumberChainable<p, omitted extends string = never> = Chainable<p, omitted> & Omit<{
    /**
     * `P.number.between(min, max)` matches **number** between `min` and `max`,
     * equal to min or equal to max.
     *
     * [Read the documentation for `P.number.between` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberbetween)
     *
     * @example
     *  match(value)
     *   .with(P.number.between(0, 10), () => '0 <= numbers <= 10')
     */
    between<input, const min extends number, const max extends number>(min: min, max: max): NumberChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, number, never>>, omitted>;
    /**
     * `P.number.lt(max)` matches **number** smaller than `max`.
     *
     * [Read the documentation for `P.number.lt` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberlt)
     *
     * @example
     *  match(value)
     *   .with(P.number.lt(10), () => 'numbers < 10')
     */
    lt<input, const max extends number>(max: max): NumberChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, number, never>>, omitted>;
    /**
     * `P.number.gt(min)` matches **number** greater than `min`.
     *
     * [Read the documentation for `P.number.gt` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumbergt)
     *
     * @example
     *  match(value)
     *   .with(P.number.gt(10), () => 'numbers > 10')
     */
    gt<input, const min extends number>(min: min): NumberChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, number, never>>, omitted>;
    /**
     * `P.number.lte(max)` matches **number** smaller than or equal to `max`.
     *
     * [Read the documentation for `P.number.lte` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberlte)
     *
     * @example
     *  match(value)
     *   .with(P.number.lte(10), () => 'numbers <= 10')
     */
    lte<input, const max extends number>(max: max): NumberChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, number, never>>, omitted>;
    /**
     * `P.number.gte(min)` matches **number** greater than or equal to `min`.
     *
     * [Read the documentation for `P.number.gte` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumbergte)
     *
     * @example
     *  match(value)
     *   .with(P.number.gte(10), () => 'numbers >= 10')
     */
    gte<input, const min extends number>(min: min): NumberChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, number, never>>, omitted>;
    /**
     * `P.number.int` matches **integer** numbers.
     *
     * [Read the documentation for `P.number.int` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberint)
     *
     * @example
     *  match(value)
     *   .with(P.number.int, () => 'an integer')
     */
    int<input>(): NumberChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, number, never>>, omitted | 'int'>;
    /**
     * `P.number.finite` matches **finite numbers**.
     *
     * [Read the documentation for `P.number.finite` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberfinite)
     *
     * @example
     *  match(value)
     *   .with(P.number.finite, () => 'not Infinity')
     */
    finite<input>(): NumberChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, number, never>>, omitted | 'finite'>;
    /**
     * `P.number.positive` matches **positive** numbers.
     *
     * [Read the documentation for `P.number.positive` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberpositive)
     *
     * @example
     *  match(value)
     *   .with(P.number.positive, () => 'number > 0')
     */
    positive<input>(): NumberChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, number, never>>, omitted | 'positive' | 'negative'>;
    /**
     * `P.number.negative` matches **negative** numbers.
     *
     * [Read the documentation for `P.number.negative` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumbernegative)
     *
     * @example
     *  match(value)
     *   .with(P.number.negative, () => 'number < 0')
     */
    negative<input>(): NumberChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, number, never>>, omitted | 'positive' | 'negative' | 'negative'>;
}, omitted>;
/**
 * `P.number` is a wildcard pattern, matching any **number**.
 *
 * [Read the documentation for `P.number` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumber-wildcard)
 *
 * @example
 *  match(value)
 *   .with(P.number, () => 'will match on numbers')
 */
export declare const number: NumberPattern;
/**
 * `P.bigint.between(min, max)` matches **bigint** between `min` and `max`,
 * equal to min or equal to max.
 *
 * [Read the documentation for `P.bigint.between` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberbetween)
 *
 * @example
 *  match(value)
 *   .with(P.bigint.between(0, 10), () => '0 <= numbers <= 10')
 */
export declare const betweenBigInt: <input, const min extends bigint, const max extends bigint>(min: min, max: max) => GuardExcludeP<input, bigint, never>;
/**
 * `P.bigint.lt(max)` matches **bigint** smaller than `max`.
 *
 * [Read the documentation for `P.bigint.lt` on GitHub](https://github.com/gvergnaud/ts-pattern#bigintlt)
 *
 * @example
 *  match(value)
 *   .with(P.bigint.lt(10), () => 'numbers < 10')
 */
export declare const ltBigInt: <input, const max extends bigint>(max: max) => GuardExcludeP<input, bigint, never>;
/**
 * `P.bigint.gt(min)` matches **bigint** greater than `min`.
 *
 * [Read the documentation for `P.bigint.gt` on GitHub](https://github.com/gvergnaud/ts-pattern#bigintgt)
 *
 * @example
 *  match(value)
 *   .with(P.bigint.gt(10), () => 'numbers > 10')
 */
export declare const gtBigInt: <input, const min extends bigint>(min: min) => GuardExcludeP<input, bigint, never>;
/**
 * `P.bigint.lte(max)` matches **bigint** smaller than or equal to `max`.
 *
 * [Read the documentation for `P.bigint.lte` on GitHub](https://github.com/gvergnaud/ts-pattern#bigintlte)
 *
 * @example
 *  match(value)
 *   .with(P.bigint.lte(10), () => 'bigints <= 10')
 */
export declare const lteBigInt: <input, const max extends bigint>(max: max) => GuardExcludeP<input, bigint, never>;
/**
 * `P.bigint.gte(min)` matches **bigint** greater than or equal to `min`.
 *
 * [Read the documentation for `P.bigint.gte` on GitHub](https://github.com/gvergnaud/ts-pattern#Pbigintgte)
 *
 * @example
 *  match(value)
 *   .with(P.bigint.gte(10), () => 'bigints >= 10')
 */
export declare const gteBigInt: <input, const min extends bigint>(min: min) => GuardExcludeP<input, bigint, never>;
/**
 * `P.bigint.positive` matches **positive** bigints.
 *
 * [Read the documentation for `P.bigint.positive` on GitHub](https://github.com/gvergnaud/ts-pattern#Pbigintpositive)
 *
 * @example
 *  match(value)
 *   .with(P.bigint.positive, () => 'bigint > 0')
 */
export declare const positiveBigInt: <input>() => GuardExcludeP<input, bigint, never>;
/**
 * `P.bigint.negative` matches **negative** bigints.
 *
 * [Read the documentation for `P.bigint.negative` on GitHub](https://github.com/gvergnaud/ts-pattern#Pbigintnegative)
 *
 * @example
 *  match(value)
 *   .with(P.bigint.negative, () => 'bigint < 0')
 */
export declare const negativeBigInt: <input>() => GuardExcludeP<input, bigint, never>;
type BigIntChainable<p, omitted extends string = never> = Chainable<p, omitted> & Omit<{
    /**
     * `P.bigint.between(min, max)` matches **bigint** between `min` and `max`,
     * equal to min or equal to max.
     *
     * [Read the documentation for `P.bigint.between` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberbetween)
     *
     * @example
     *  match(value)
     *   .with(P.bigint.between(0, 10), () => '0 <= numbers <= 10')
     */
    between<input, const min extends bigint, const max extends bigint>(min: min, max: max): BigIntChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, bigint, never>>, omitted>;
    /**
     * `P.bigint.lt(max)` matches **bigint** smaller than `max`.
     *
     * [Read the documentation for `P.bigint.lt` on GitHub](https://github.com/gvergnaud/ts-pattern#bigintlt)
     *
     * @example
     *  match(value)
     *   .with(P.bigint.lt(10), () => 'numbers < 10')
     */
    lt<input, const max extends bigint>(max: max): BigIntChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, bigint, never>>, omitted>;
    /**
     * `P.bigint.gt(min)` matches **bigint** greater than `min`.
     *
     * [Read the documentation for `P.bigint.gt` on GitHub](https://github.com/gvergnaud/ts-pattern#bigintgt)
     *
     * @example
     *  match(value)
     *   .with(P.bigint.gt(10), () => 'numbers > 10')
     */
    gt<input, const min extends bigint>(min: min): BigIntChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, bigint, never>>, omitted>;
    /**
     * `P.bigint.lte(max)` matches **bigint** smaller than or equal to `max`.
     *
     * [Read the documentation for `P.bigint.lte` on GitHub](https://github.com/gvergnaud/ts-pattern#bigintlte)
     *
     * @example
     *  match(value)
     *   .with(P.bigint.lte(10), () => 'bigints <= 10')
     */
    lte<input, const max extends bigint>(max: max): BigIntChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, bigint, never>>, omitted>;
    /**
     * `P.bigint.gte(min)` matches **bigint** greater than or equal to `min`.
     *
     * [Read the documentation for `P.bigint.gte` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumbergte)
     *
     * @example
     *  match(value)
     *   .with(P.bigint.gte(10), () => 'bigints >= 10')
     */
    gte<input, const min extends bigint>(min: min): BigIntChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, bigint, never>>, omitted>;
    /**
     * `P.bigint.positive` matches **positive** bigints.
     *
     * [Read the documentation for `P.bigint.positive` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberpositive)
     *
     * @example
     *  match(value)
     *   .with(P.bigint.positive, () => 'bigint > 0')
     */
    positive<input>(): BigIntChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, bigint, never>>, omitted | 'positive' | 'negative'>;
    /**
     * `P.bigint.negative` matches **negative** bigints.
     *
     * [Read the documentation for `P.bigint.negative` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumbernegative)
     *
     * @example
     *  match(value)
     *   .with(P.bigint.negative, () => 'bigint < 0')
     */
    negative<input>(): BigIntChainable<MaybeAnd<omitted, input, p, GuardExcludeP<input, bigint, never>>, omitted | 'positive' | 'negative' | 'negative'>;
}, omitted>;
/**
 * `P.bigint` is a wildcard pattern, matching any **bigint**.
 *
 * [Read the documentation for `P.bigint` on GitHub](https://github.com/gvergnaud/ts-pattern#bigint-wildcard)
 *
 * @example
 *   .with(P.bigint, () => 'will match on bigints')
 */
export declare const bigint: BigIntPattern;
/**
 * `P.boolean` is a wildcard pattern, matching any **boolean**.
 *
 * [Read the documentation for `P.boolean` on GitHub](https://github.com/gvergnaud/ts-pattern#boolean-wildcard)
 *
 * @example
 *   .with(P.boolean, () => 'will match on booleans')
 */
export declare const boolean: BooleanPattern;
/**
 * `P.symbol` is a wildcard pattern, matching any **symbol**.
 *
 * [Read the documentation for `P.symbol` on GitHub](https://github.com/gvergnaud/ts-pattern#symbol-wildcard)
 *
 * @example
 *   .with(P.symbol, () => 'will match on symbols')
 */
export declare const symbol: SymbolPattern;
/**
 * `P.nullish` is a wildcard pattern, matching **null** or **undefined**.
 *
 * [Read the documentation for `P.nullish` on GitHub](https://github.com/gvergnaud/ts-pattern#nullish-wildcard)
 *
 * @example
 *   .with(P.nullish, () => 'will match on null or undefined')
 */
export declare const nullish: NullishPattern;
/**
 * `P.instanceOf(SomeClass)` is a pattern matching instances of a given class.
 *
 * [Read the documentation for `P.instanceOf` on GitHub](https://github.com/gvergnaud/ts-pattern#Pinstanceof-patterns)
 *
 *  @example
 *   .with(P.instanceOf(SomeClass), () => 'will match on SomeClass instances')
 */
export declare function instanceOf<T extends AnyConstructor>(classConstructor: T): Chainable<GuardP<unknown, InstanceType<T>>>;
/**
 * `P.shape(somePattern)` lets you call methods like `.optional()`, `.and`, `.or` and `.select()`
 * On structural patterns, like objects and arrays.
 *
 * [Read the documentation for `P.shape` on GitHub](https://github.com/gvergnaud/ts-pattern#Pshape-patterns)
 *
 *  @example
 *   .with(
 *     {
 *       state: P.shape({ status: "success" }).optional().select()
 *     },
 *     (state) => 'match the success state, or undefined.'
 *   )
 */
export declare function shape<input, const p extends Pattern<input>>(pattern: p): Chainable<GuardP<input, InvertPattern<p, input>>>;
