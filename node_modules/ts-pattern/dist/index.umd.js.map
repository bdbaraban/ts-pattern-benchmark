{"version":3,"file":"index.umd.js","sources":["../src/internals/symbols.ts","../src/internals/helpers.ts","../src/is-matching.ts","../src/patterns.ts","../src/match.ts"],"sourcesContent":["/**\n * Symbols used internally within ts-pattern to construct and discriminate\n * Guard, Not, and Select, and AnonymousSelect patterns\n *\n * Symbols have the advantage of not appearing in auto-complete suggestions in\n * user defined patterns, and eliminate the risk of property\n * overlap between ts-pattern internals and user defined patterns.\n *\n * These symbols have to be visible to tsc for type inference to work, but\n * users should not import them\n * @module\n * @private\n * @internal\n */\n\nexport const matcher = Symbol('@ts-pattern/matcher');\nexport type matcher = typeof matcher;\n\nexport const unset = Symbol('@ts-pattern/unset');\nexport type unset = typeof unset;\n\nexport const isVariadic = Symbol('@ts-pattern/isVariadic');\nexport type isVariadic = typeof isVariadic;\n\nexport const anonymousSelectKey = '@ts-pattern/anonymous-select-key';\nexport type anonymousSelectKey = typeof anonymousSelectKey;\n\nexport const override = Symbol('@ts-pattern/override');\nexport type override = typeof override;\n","/**\n * @module\n * @private\n * @internal\n */\n\nimport * as symbols from './symbols';\nimport { SelectionType } from '../types/FindSelected';\nimport { Pattern, Matcher, MatcherType, AnyMatcher } from '../types/Pattern';\n\n// @internal\nexport const isObject = (value: unknown): value is Object =>\n  Boolean(value && typeof value === 'object');\n\n//   @internal\nexport const isMatcher = (\n  x: unknown\n): x is Matcher<unknown, unknown, MatcherType, SelectionType> => {\n  const pattern = x as Matcher<unknown, unknown, MatcherType, SelectionType>;\n  return pattern && !!pattern[symbols.matcher];\n};\n\n// @internal\nconst isOptionalPattern = (\n  x: unknown\n): x is Matcher<unknown, unknown, 'optional', SelectionType> => {\n  return isMatcher(x) && x[symbols.matcher]().matcherType === 'optional';\n};\n\n// tells us if the value matches a given pattern.\n// @internal\nexport const matchPattern = (\n  pattern: any,\n  value: any,\n  select: (key: string, value: unknown) => void\n): boolean => {\n  if (isMatcher(pattern)) {\n    const matcher = pattern[symbols.matcher]();\n    const { matched, selections } = matcher.match(value);\n    if (matched && selections) {\n      Object.keys(selections).forEach((key) => select(key, selections[key]));\n    }\n    return matched;\n  }\n\n  if (isObject(pattern)) {\n    if (!isObject(value)) return false;\n\n    // Tuple pattern\n    if (Array.isArray(pattern)) {\n      if (!Array.isArray(value)) return false;\n      let startPatterns = [];\n      let endPatterns = [];\n      let variadicPatterns: AnyMatcher[] = [];\n\n      for (const i of pattern.keys()) {\n        const subpattern = pattern[i];\n        if (isMatcher(subpattern) && subpattern[symbols.isVariadic]) {\n          variadicPatterns.push(subpattern);\n        } else if (variadicPatterns.length) {\n          endPatterns.push(subpattern);\n        } else {\n          startPatterns.push(subpattern);\n        }\n      }\n\n      if (variadicPatterns.length) {\n        if (variadicPatterns.length > 1) {\n          throw new Error(\n            `Pattern error: Using \\`...P.array(...)\\` several times in a single pattern is not allowed.`\n          );\n        }\n\n        if (value.length < startPatterns.length + endPatterns.length) {\n          return false;\n        }\n\n        const startValues = value.slice(0, startPatterns.length);\n        const endValues =\n          endPatterns.length === 0 ? [] : value.slice(-endPatterns.length);\n        const middleValues = value.slice(\n          startPatterns.length,\n          endPatterns.length === 0 ? Infinity : -endPatterns.length\n        );\n\n        return (\n          startPatterns.every((subPattern, i) =>\n            matchPattern(subPattern, startValues[i], select)\n          ) &&\n          endPatterns.every((subPattern, i) =>\n            matchPattern(subPattern, endValues[i], select)\n          ) &&\n          (variadicPatterns.length === 0\n            ? true\n            : matchPattern(variadicPatterns[0], middleValues, select))\n        );\n      }\n\n      return pattern.length === value.length\n        ? pattern.every((subPattern, i) =>\n            matchPattern(subPattern, value[i], select)\n          )\n        : false;\n    }\n\n    return Object.keys(pattern).every((k: string): boolean => {\n      // @ts-ignore\n      const subPattern = pattern[k];\n\n      return (\n        (k in value || isOptionalPattern(subPattern)) &&\n        matchPattern(\n          subPattern,\n          // @ts-ignore\n          value[k],\n          select\n        )\n      );\n    });\n  }\n\n  return Object.is(value, pattern);\n};\n\n// @internal\nexport const getSelectionKeys = (pattern: any): string[] => {\n  if (isObject(pattern)) {\n    if (isMatcher(pattern)) {\n      return pattern[symbols.matcher]().getSelectionKeys?.() ?? [];\n    }\n    if (Array.isArray(pattern)) return flatMap(pattern, getSelectionKeys);\n    return flatMap(Object.values(pattern), getSelectionKeys);\n  }\n  return [];\n};\n\n// @internal\nexport const flatMap = <a, b>(\n  xs: readonly a[],\n  f: (v: a) => readonly b[]\n): b[] => xs.reduce<b[]>((acc, p) => acc.concat(f(p)), []);\n","import { MatchedValue, Pattern } from './types/Pattern';\nimport * as P from './patterns';\nimport { matchPattern } from './internals/helpers';\n\n/**\n * `isMatching` takes pattern and returns a **type guard** function, cheching if a value matches this pattern.\n *\n * [Read  documentation for `isMatching` on GitHub](https://github.com/gvergnaud/ts-pattern#ismatching)\n *\n * @example\n *  const hasName = isMatching({ name: P.string })\n *\n *  declare let input: unknown\n *\n *  if (hasName(input)) {\n *    // `input` inferred as { name: string }\n *    return input.name\n *  }\n */\nexport function isMatching<p extends Pattern<unknown>>(\n  pattern: p\n): (value: unknown) => value is P.infer<p>;\n/**\n * `isMatching` takes pattern and a value and checks if the value matches this pattern.\n *\n * [Read  documentation for `isMatching` on GitHub](https://github.com/gvergnaud/ts-pattern#ismatching)\n *\n * @example\n *  declare let input: unknown\n *\n *  if (isMatching({ name: P.string }, input)) {\n *    // `input` inferred as { name: string }\n *    return input.name\n *  }\n */\nexport function isMatching<p extends Pattern<unknown>>(\n  pattern: p,\n  value: unknown\n): value is P.infer<p>;\n\nexport function isMatching<p extends Pattern<any>>(\n  ...args: [pattern: p, value?: any]\n): boolean | ((vale: any) => boolean) {\n  if (args.length === 1) {\n    const [pattern] = args;\n    return (value: any): value is MatchedValue<any, P.infer<p>> =>\n      matchPattern(pattern, value, () => {});\n  }\n  if (args.length === 2) {\n    const [pattern, value] = args;\n    return matchPattern(pattern, value, () => {});\n  }\n\n  throw new Error(\n    `isMatching wasn't given the right number of arguments: expected 1 or 2, received ${args.length}.`\n  );\n}\n","import { matchPattern, getSelectionKeys, flatMap } from './internals/helpers';\nimport * as symbols from './internals/symbols';\nimport { matcher } from './internals/symbols';\nimport { isMatching } from './is-matching';\nimport { ExtractPreciseValue } from './types/ExtractPreciseValue';\nimport { Fn } from './types/helpers';\nimport { InvertPattern } from './types/InvertPattern';\nimport {\n  Pattern,\n  UnknownPattern,\n  OptionalP,\n  ArrayP,\n  MapP,\n  SetP,\n  AndP,\n  OrP,\n  NotP,\n  GuardP,\n  SelectP,\n  AnonymousSelectP,\n  GuardExcludeP,\n  CustomP,\n  Matcher,\n} from './types/Pattern';\n\nexport { Pattern, Fn as unstable_Fn };\n\nexport { matcher };\n\n/**\n * @experimental\n * A `Matchable` is an object implementing\n * the Matcher Protocol. It must have a `[P.matcher]: P.Matcher<NarrowFn>`\n * key, which defines how this object should be matched by TS-Pattern.\n *\n * Note that this api is unstable.\n *\n * @example\n * ```ts\n * class Some<T> implements P.unstable_Matchable {\n *  [P.matcher](): P.unstable_Matcher<Some<T>>\n * }\n * ```\n */\nexport type unstable_Matchable<\n  narrowedOrFn,\n  input = unknown,\n  pattern = never\n> = CustomP<input, pattern, narrowedOrFn>;\n\n/**\n * @experimental\n * A `Matcher` is an object with `match` function, which\n * defines how this object should be matched by TS-Pattern.\n *\n * Note that this api is unstable.\n *\n * @example\n * ```ts\n * class Some<T> implements P.unstable_Matchable {\n *  [P.matcher](): P.unstable_Matcher<Some<T>>\n * }\n * ```\n */\nexport type unstable_Matcher<\n  narrowedOrFn,\n  input = unknown,\n  pattern = never\n> = ReturnType<CustomP<input, pattern, narrowedOrFn>[matcher]>;\n\n/**\n * `P.infer<typeof somePattern>` will return the type of the value\n * matched by this pattern.\n *\n * [Read the documentation for `P.infer` on GitHub](https://github.com/gvergnaud/ts-pattern#Pinfer)\n *\n * @example\n * const userPattern = { name: P.stringÂ }\n * type User = P.infer<typeof userPattern>\n */\nexport type infer<p extends Pattern<any>> = InvertPattern<p, unknown>;\n\nexport type narrow<i, p extends Pattern<any>> = ExtractPreciseValue<\n  i,\n  InvertPattern<p, i>\n>;\n\ntype Chainable<p, omitted extends string = never> = p &\n  Omit<\n    {\n      /**\n       * `.optional()` returns a pattern which matches if the\n       * key is undefined or if it is defined and the previous pattern matches its value.\n       *\n       * [Read the documentation for `P.optional` on GitHub](https://github.com/gvergnaud/ts-pattern#Poptional-patterns)\n       *\n       * @example\n       *  match(value)\n       *   .with({ greeting: P.string.optional() }, () => 'will match { greeting?: string}')\n       */\n      optional<input>(): Chainable<OptionalP<input, p>, omitted | 'optional'>;\n      /**\n       * `pattern.and(pattern)` returns a pattern that matches\n       * if the previous pattern and the next one match the input.\n       *\n       * [Read the documentation for `P.intersection` on GitHub](https://github.com/gvergnaud/ts-pattern#Pintersection-patterns)\n       *\n       * @example\n       *  match(value)\n       *   .with(\n       *     P.string.and(P.when(isUsername)),\n       *     (username) => '...'\n       *   )\n       */\n      and<input, p2 extends Pattern<input>>(\n        pattern: p2\n      ): Chainable<AndP<input, [p, p2]>, omitted>;\n      /**\n       * `pattern.or(pattern)` returns a pattern that matches\n       * if **either** the previous pattern or the next one match the input.\n       *\n       * [Read the documentation for `P.union` on GitHub](https://github.com/gvergnaud/ts-pattern#Punion-patterns)\n       *\n       * @example\n       *  match(value)\n       *   .with(\n       *     { value: P.string.or(P.number) },\n       *     ({ value }) => 'value: number | string'\n       *   )\n       */\n      or<input, p2 extends Pattern<input>>(\n        pattern: p2\n      ): Chainable<OrP<input, [p, p2]>, omitted>;\n      /**\n       * `P.select()` will inject this property into the handler function's arguments.\n       *\n       * [Read the documentation for `P.select` on GitHub](https://github.com/gvergnaud/ts-pattern#Pselect-patterns)\n       *\n       * @example\n       *  match<{ age: number }>(value)\n       *   .with({ age: P.string.select() }, (age) => 'age: number')\n       */\n      select<input>(): Chainable<\n        SelectP<symbols.anonymousSelectKey, input, p>,\n        omitted | 'select' | 'or' | 'and'\n      >;\n      select<input, k extends string>(\n        key: k\n      ): Chainable<SelectP<k, input, p>, omitted | 'select' | 'or' | 'and'>;\n    },\n    omitted\n  >;\n\nfunction chainable<p extends Matcher<any, any, any, any, any>>(\n  pattern: p\n): Chainable<p> {\n  return Object.assign(pattern, {\n    optional: () => optional(pattern),\n    and: (p2: any) => intersection(pattern, p2),\n    or: (p2: any) => union(pattern, p2),\n    select: (key: any) =>\n      key === undefined ? select(pattern) : select(key, pattern),\n  }) as Chainable<p>;\n}\n\ntype Variadic<p> = p & Iterable<p>;\n\nconst variadic = <p extends {}>(pattern: p): Variadic<p> =>\n  Object.assign(pattern, {\n    *[Symbol.iterator]() {\n      yield Object.assign(pattern, {\n        [symbols.isVariadic]: true,\n      });\n    },\n  });\n\ntype ArrayChainable<p, omitted extends string = never> = Variadic<p> &\n  Omit<\n    {\n      /**\n       * `.optional()` returns a pattern which matches if the\n       * key is undefined or if it is defined and the previous pattern matches its value.\n       *\n       * [Read the documentation for `P.optional` on GitHub](https://github.com/gvergnaud/ts-pattern#Poptional-patterns)\n       *\n       * @example\n       *  match(value)\n       *   .with({ greeting: P.string.optional() }, () => 'will match { greeting?: string}')\n       */\n      optional<input>(): ArrayChainable<\n        OptionalP<input, p>,\n        omitted | 'optional'\n      >;\n      /**\n       * `P.select()` will inject this property into the handler function's arguments.\n       *\n       * [Read the documentation for `P.select` on GitHub](https://github.com/gvergnaud/ts-pattern#Pselect-patterns)\n       *\n       * @example\n       *  match<{ age: number }>(value)\n       *   .with({ age: P.string.select() }, (age) => 'age: number')\n       */\n      select<input>(): ArrayChainable<\n        SelectP<symbols.anonymousSelectKey, input, p>,\n        omitted | 'select'\n      >;\n      select<input, k extends string>(\n        key: k\n      ): ArrayChainable<SelectP<k, input, p>, omitted | 'select'>;\n    },\n    omitted\n  >;\n\nfunction arrayChainable<p extends Matcher<any, any, any, any, any>>(\n  pattern: p\n): ArrayChainable<p> {\n  return Object.assign(variadic(pattern), {\n    optional: () => arrayChainable(optional(pattern)),\n    select: (key: any) =>\n      arrayChainable(\n        key === undefined ? select(pattern) : select(key, pattern)\n      ),\n  }) as any;\n}\n\n/**\n * `P.optional(subpattern)` takes a sub pattern and returns a pattern which matches if the\n * key is undefined or if it is defined and the sub pattern matches its value.\n *\n * [Read the documentation for `P.optional` on GitHub](https://github.com/gvergnaud/ts-pattern#Poptional-patterns)\n *\n * @example\n *  match(value)\n *   .with({ greeting: P.optional('Hello') }, () => 'will match { greeting?: \"Hello\"Â }')\n */\nexport function optional<\n  input,\n  const p extends unknown extends input ? UnknownPattern : Pattern<input>\n>(pattern: p): Chainable<OptionalP<input, p>, 'optional'> {\n  return chainable({\n    [matcher]() {\n      return {\n        match: <UnknownInput>(value: UnknownInput | input) => {\n          let selections: Record<string, unknown[]> = {};\n          const selector = (key: string, value: any) => {\n            selections[key] = value;\n          };\n          if (value === undefined) {\n            getSelectionKeys(pattern).forEach((key) =>\n              selector(key, undefined)\n            );\n            return { matched: true, selections };\n          }\n          const matched = matchPattern(pattern, value, selector);\n          return { matched, selections };\n        },\n        getSelectionKeys: () => getSelectionKeys(pattern),\n        matcherType: 'optional',\n      };\n    },\n  });\n}\n\ntype UnwrapArray<xs> = xs extends readonly (infer x)[] ? x : never;\n\ntype UnwrapSet<xs> = xs extends Set<infer x> ? x : never;\n\ntype UnwrapMapKey<xs> = xs extends Map<infer k, any> ? k : never;\n\ntype UnwrapMapValue<xs> = xs extends Map<any, infer v> ? v : never;\n\ntype WithDefault<a, b> = [a] extends [never] ? b : a;\n\n/**\n * `P.array(subpattern)` takes a sub pattern and returns a pattern, which matches\n * arrays if all their elements match the sub pattern.\n *\n * [Read the documentation for `P.array` on GitHub](https://github.com/gvergnaud/ts-pattern#Parray-patterns)\n *\n * @example\n *  match(value)\n *   .with({ users: P.array({ name: P.string }) }, () => 'will match { name: stringÂ }[]')\n */\nexport function array<input>(): ArrayChainable<ArrayP<input, unknown>>;\nexport function array<\n  input,\n  const p extends Pattern<WithDefault<UnwrapArray<input>, unknown>>\n>(pattern: p): ArrayChainable<ArrayP<input, p>>;\nexport function array(\n  ...args: [pattern?: any]\n): ArrayChainable<ArrayP<any, any>> {\n  return arrayChainable({\n    [matcher]() {\n      return {\n        match: (value: any) => {\n          if (!Array.isArray(value)) return { matched: false };\n\n          if (args.length === 0) return { matched: true };\n\n          const pattern = args[0];\n          let selections: Record<string, unknown[]> = {};\n\n          if (value.length === 0) {\n            getSelectionKeys(pattern).forEach((key) => {\n              selections[key] = [];\n            });\n            return { matched: true, selections };\n          }\n\n          const selector = (key: string, value: unknown) => {\n            selections[key] = (selections[key] || []).concat([value]);\n          };\n\n          const matched = value.every((v) =>\n            matchPattern(pattern, v, selector)\n          );\n\n          return { matched, selections };\n        },\n        getSelectionKeys: () =>\n          args.length === 0 ? [] : getSelectionKeys(args[0]),\n      };\n    },\n  });\n}\n\n/**\n * `P.set(subpattern)` takes a sub pattern and returns a pattern that matches\n * sets if all their elements match the sub pattern.\n *\n * [Read `P.set` documentation on GitHub](https://github.com/gvergnaud/ts-pattern#Pset-patterns)\n *\n * @example\n *  match(value)\n *   .with({ users: P.set(P.string) }, () => 'will match Set<string>')\n */\nexport function set<input>(): Chainable<SetP<input, unknown>>;\nexport function set<\n  input,\n  const p extends Pattern<WithDefault<UnwrapSet<input>, unknown>>\n>(pattern: p): Chainable<SetP<input, p>>;\nexport function set<\n  input,\n  const p extends Pattern<WithDefault<UnwrapSet<input>, unknown>>\n>(...args: [pattern?: p]): Chainable<SetP<input, p>> {\n  return chainable({\n    [matcher]() {\n      return {\n        match: <UnknownInput>(value: UnknownInput | input) => {\n          if (!(value instanceof Set)) return { matched: false };\n\n          let selections: Record<string, unknown[]> = {};\n\n          if (value.size === 0) {\n            return { matched: true, selections };\n          }\n\n          if (args.length === 0) return { matched: true };\n\n          const selector = (key: string, value: unknown) => {\n            selections[key] = (selections[key] || []).concat([value]);\n          };\n\n          const pattern = args[0];\n\n          const matched = setEvery(value, (v) =>\n            matchPattern(pattern, v, selector)\n          );\n\n          return { matched, selections };\n        },\n        getSelectionKeys: () =>\n          args.length === 0 ? [] : getSelectionKeys(args[0]),\n      };\n    },\n  });\n}\n\nconst setEvery = <T>(set: Set<T>, predicate: (value: T) => boolean) => {\n  for (const value of set) {\n    if (predicate(value)) continue;\n    return false;\n  }\n  return true;\n};\n\n/**\n * `P.set(subpattern)` takes a sub pattern and returns a pattern that matches\n * sets if all their elements match the sub pattern.\n *\n * [Read `P.set` documentation on GitHub](https://github.com/gvergnaud/ts-pattern#Pset-patterns)\n *\n * @example\n *  match(value)\n *   .with({ users: P.set(P.string) }, () => 'will match Set<string>')\n */\nexport function map<input>(): Chainable<MapP<input, unknown, unknown>>;\nexport function map<\n  input,\n  const pkey extends Pattern<WithDefault<UnwrapMapKey<input>, unknown>>,\n  const pvalue extends Pattern<WithDefault<UnwrapMapValue<input>, unknown>>\n>(patternKey: pkey, patternValue: pvalue): Chainable<MapP<input, pkey, pvalue>>;\nexport function map<\n  input,\n  const pkey extends Pattern<WithDefault<UnwrapMapKey<input>, unknown>>,\n  const pvalue extends Pattern<WithDefault<UnwrapMapValue<input>, unknown>>\n>(\n  ...args: [patternKey?: pkey, patternValue?: pvalue]\n): Chainable<MapP<input, pkey, pvalue>> {\n  return chainable({\n    [matcher]() {\n      return {\n        match: <UnknownInput>(value: UnknownInput | input) => {\n          if (!(value instanceof Map)) return { matched: false };\n\n          let selections: Record<string, unknown[]> = {};\n\n          if (value.size === 0) {\n            return { matched: true, selections };\n          }\n\n          const selector = (key: string, value: unknown) => {\n            selections[key] = (selections[key] || []).concat([value]);\n          };\n\n          if (args.length === 0) return { matched: true };\n          if (args.length === 1) {\n            throw new Error(\n              `\\`P.map\\` wasn\\'t given enough arguments. Expected (key, value), received ${args[0]?.toString()}`\n            );\n          }\n          const [patternKey, patternValue] = args;\n\n          const matched = mapEvery(value, (v, k) => {\n            const keyMatch = matchPattern(patternKey, k, selector);\n            const valueMatch = matchPattern(patternValue, v, selector);\n            return keyMatch && valueMatch;\n          });\n\n          return { matched, selections };\n        },\n        getSelectionKeys: () =>\n          args.length === 0\n            ? []\n            : [...getSelectionKeys(args[0]), ...getSelectionKeys(args[1])],\n      };\n    },\n  });\n}\n\nconst mapEvery = <K, T>(\n  map: Map<K, T>,\n  predicate: (value: T, key: K) => boolean\n) => {\n  for (const [key, value] of map.entries()) {\n    if (predicate(value, key)) continue;\n    return false;\n  }\n  return true;\n};\n\n/**\n * `P.intersection(...patterns)` returns a pattern which matches\n * only if **every** patterns provided in parameter match the input.\n *\n * [Read the documentation for `P.intersection` on GitHub](https://github.com/gvergnaud/ts-pattern#Pintersection-patterns)\n *\n * @example\n *  match(value)\n *   .with(\n *     {\n *       user: P.intersection(\n *         { firstname: P.string },\n *         { lastname: P.string },\n *         { age: P.when(age => age > 21) }\n *       )\n *     },\n *     ({ user }) => 'will match { firstname: string, lastname: string, age: number } if age > 21'\n *   )\n */\nexport function intersection<\n  input,\n  const ps extends readonly [Pattern<input>, ...Pattern<input>[]]\n>(...patterns: ps): Chainable<AndP<input, ps>> {\n  return chainable({\n    [matcher]: () => ({\n      match: (value) => {\n        let selections: Record<string, unknown[]> = {};\n        const selector = (key: string, value: any) => {\n          selections[key] = value;\n        };\n        const matched = (patterns as readonly UnknownPattern[]).every((p) =>\n          matchPattern(p, value, selector)\n        );\n        return { matched, selections };\n      },\n      getSelectionKeys: () =>\n        flatMap(patterns as readonly UnknownPattern[], getSelectionKeys),\n      matcherType: 'and',\n    }),\n  });\n}\n\n/**\n * `P.union(...patterns)` returns a pattern which matches\n * if **at least one** of the patterns provided in parameter match the input.\n *\n * [Read the documentation for `P.union` on GitHub](https://github.com/gvergnaud/ts-pattern#Punion-patterns)\n *\n * @example\n *  match(value)\n *   .with(\n *     { type: P.union('a', 'b', 'c') },\n *     ({ type }) => 'will match { type: \"a\" | \"b\" | \"c\" }'\n *   )\n */\nexport function union<\n  input,\n  const ps extends readonly [Pattern<input>, ...Pattern<input>[]]\n>(...patterns: ps): Chainable<OrP<input, ps>> {\n  return chainable({\n    [matcher]: () => ({\n      match: <UnknownInput>(value: UnknownInput | input) => {\n        let selections: Record<string, unknown[]> = {};\n        const selector = (key: string, value: any) => {\n          selections[key] = value;\n        };\n        flatMap(\n          patterns as readonly UnknownPattern[],\n          getSelectionKeys\n        ).forEach((key) => selector(key, undefined));\n        const matched = (patterns as readonly UnknownPattern[]).some((p) =>\n          matchPattern(p, value, selector)\n        );\n        return { matched, selections };\n      },\n      getSelectionKeys: () =>\n        flatMap(patterns as readonly UnknownPattern[], getSelectionKeys),\n      matcherType: 'or',\n    }),\n  });\n}\n\n/**\n * `P.not(pattern)` returns a pattern which matches if the sub pattern\n * doesn't match.\n *\n * [Read the documentation for `P.not` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnot-patterns)\n *\n * @example\n *  match<{ a: string | number }>(value)\n *   .with({ a: P.not(P.string) }, (x) => 'will match { a: number }'\n *   )\n */\n\nexport function not<input, const p extends Pattern<input> | UnknownPattern>(\n  pattern: p\n): Chainable<NotP<input, p>> {\n  return chainable({\n    [matcher]: () => ({\n      match: <UnknownInput>(value: UnknownInput | input) => ({\n        matched: !matchPattern(pattern, value, () => {}),\n      }),\n      getSelectionKeys: () => [],\n      matcherType: 'not',\n    }),\n  });\n}\n\n/**\n * `P.when((value) => boolean)` returns a pattern which matches\n * if the predicate returns true for the current input.\n *\n * [Read the documentation for `P.when` on GitHub](https://github.com/gvergnaud/ts-pattern#Pwhen-patterns)\n *\n * @example\n *  match<{ age: number }>(value)\n *   .with({ age: P.when(age => age > 21) }, (x) => 'will match if value.age > 21'\n *   )\n */\nexport function when<input, p extends (value: input) => unknown>(\n  predicate: p\n): GuardP<\n  input,\n  p extends (value: any) => value is infer narrowed ? narrowed : never\n>;\nexport function when<input, narrowed extends input, excluded>(\n  predicate: (input: input) => input is narrowed\n): GuardExcludeP<input, narrowed, excluded>;\nexport function when<input, p extends (value: input) => unknown>(\n  predicate: p\n): GuardP<\n  input,\n  p extends (value: any) => value is infer narrowed ? narrowed : never\n> {\n  return {\n    [matcher]: () => ({\n      match: <UnknownInput>(value: UnknownInput | input) => ({\n        matched: Boolean(predicate(value as input)),\n      }),\n    }),\n  };\n}\n\n/**\n * `P.select()` is a pattern which will always match,\n * and will inject the selected piece of input in the handler function.\n *\n * [Read the documentation for `P.select` on GitHub](https://github.com/gvergnaud/ts-pattern#Pselect-patterns)\n *\n * @example\n *  match<{ age: number }>(value)\n *   .with({ age: P.select() }, (age) => 'age: number'\n *   )\n */\nexport function select(): Chainable<AnonymousSelectP, 'select' | 'or' | 'and'>;\nexport function select<\n  input,\n  const patternOrKey extends\n    | string\n    | (unknown extends input ? UnknownPattern : Pattern<input>)\n>(\n  patternOrKey: patternOrKey\n): patternOrKey extends string\n  ? Chainable<SelectP<patternOrKey, 'select' | 'or' | 'and'>>\n  : Chainable<\n      SelectP<symbols.anonymousSelectKey, input, patternOrKey>,\n      'select' | 'or' | 'and'\n    >;\nexport function select<\n  input,\n  const p extends unknown extends input ? UnknownPattern : Pattern<input>,\n  const k extends string\n>(key: k, pattern: p): Chainable<SelectP<k, input, p>, 'select' | 'or' | 'and'>;\nexport function select(\n  ...args: [keyOrPattern?: unknown | string, pattern?: unknown]\n): Chainable<SelectP<string>, 'select' | 'or' | 'and'> {\n  const key: string | undefined =\n    typeof args[0] === 'string' ? args[0] : undefined;\n  const pattern: unknown =\n    args.length === 2\n      ? args[1]\n      : typeof args[0] === 'string'\n      ? undefined\n      : args[0];\n  return chainable({\n    [matcher]() {\n      return {\n        match: (value) => {\n          let selections: Record<string, unknown> = {\n            [key ?? symbols.anonymousSelectKey]: value,\n          };\n          const selector = (key: string, value: any) => {\n            selections[key] = value;\n          };\n          return {\n            matched:\n              pattern === undefined\n                ? true\n                : matchPattern(pattern, value, selector),\n            selections: selections,\n          };\n        },\n        getSelectionKeys: () =>\n          [key ?? symbols.anonymousSelectKey].concat(\n            pattern === undefined ? [] : getSelectionKeys(pattern)\n          ),\n      };\n    },\n  });\n}\n\nfunction isUnknown(x: unknown): x is unknown {\n  return true;\n}\n\nfunction isNumber<T>(x: T | number): x is number {\n  return typeof x === 'number';\n}\n\nfunction isString<T>(x: T | string): x is string {\n  return typeof x === 'string';\n}\n\nfunction isBoolean<T>(x: T | boolean): x is boolean {\n  return typeof x === 'boolean';\n}\n\nfunction isBigInt<T>(x: T | bigint): x is bigint {\n  return typeof x === 'bigint';\n}\n\nfunction isSymbol<T>(x: T | symbol): x is symbol {\n  return typeof x === 'symbol';\n}\n\nfunction isNullish<T>(x: T | null | undefined): x is null | undefined {\n  return x === null || x === undefined;\n}\n\ntype AnyConstructor = abstract new (...args: any[]) => any;\n\nfunction isInstanceOf<T extends AnyConstructor>(classConstructor: T) {\n  return (val: unknown): val is InstanceType<T> =>\n    val instanceof classConstructor;\n}\n\n// These aliases could be inferred, but lead to nicer display names in IDEs.\ntype AnyPattern = Chainable<GuardP<unknown, unknown>, never>;\ntype StringPattern = StringChainable<GuardP<unknown, string>, never>;\ntype NumberPattern = NumberChainable<GuardP<unknown, number>, never>;\ntype BooleanPattern = Chainable<GuardP<unknown, boolean>, never>;\ntype BigIntPattern = BigIntChainable<GuardP<unknown, bigint>, never>;\ntype SymbolPattern = Chainable<GuardP<unknown, symbol>, never>;\ntype NullishPattern = Chainable<GuardP<unknown, null | undefined>, never>;\n\n/**\n * `P.any` is a wildcard pattern, matching **any value**.\n *\n * [Read the documentation for `P.any` on GitHub](https://github.com/gvergnaud/ts-pattern#P_-wildcard)\n *\n * @example\n *  match(value)\n *   .with(P.any, () => 'will always match')\n */\nexport const any: AnyPattern = chainable(when(isUnknown));\n\n/**\n * `P._` is a wildcard pattern, matching **any value**.\n * It's an alias to `P.any`.\n *\n * [Read the documentation for `P._` on GitHub](https://github.com/gvergnaud/ts-pattern#P_-wildcard)\n *\n * @example\n *  match(value)\n *   .with(P._, () => 'will always match')\n */\nexport const _ = any;\n\n/**\n * `P.string.startsWith(start)` is a pattern, matching **strings** starting with `start`.\n *\n * [Read the documentation for `P.string.startsWith` on GitHub](https://github.com/gvergnaud/ts-pattern#PstringstartsWith)\n *\n * @example\n *  match(value)\n *   .with(P.string.startsWith('A'), () => 'value starts with an A')\n */\n\nconst startsWith = <input, const start extends string>(\n  start: start\n): GuardP<input, `${start}${string}`> =>\n  when((value) => isString(value) && value.startsWith(start));\n\n/**\n * `P.string.endsWith(end)` is a pattern, matching **strings** ending with `end`.\n *\n * [Read the documentation for `P.string.endsWith` on GitHub](https://github.com/gvergnaud/ts-pattern#PstringendsWith)\n *\n * @example\n *  match(value)\n *   .with(P.string.endsWith('!'), () => 'value ends with an !')\n */\nconst endsWith = <input, const end extends string>(\n  end: end\n): GuardP<input, `${string}${end}`> =>\n  when((value) => isString(value) && value.endsWith(end));\n\n/**\n * `P.string.minLength(min)` is a pattern, matching **strings** with at least `min` characters.\n *\n * [Read the documentation for `P.string.minLength` on GitHub](https://github.com/gvergnaud/ts-pattern#PstringminLength)\n *\n * @example\n *  match(value)\n *   .with(P.string.minLength(10), () => 'string with more length >= 10')\n */\nconst minLength = <const min extends number>(min: min) =>\n  when((value) => isString(value) && value.length >= min);\n\n/**\n * `P.string.maxLength(max)` is a pattern, matching **strings** with at most `max` characters.\n *\n * [Read the documentation for `P.string.maxLength` on GitHub](https://github.com/gvergnaud/ts-pattern#PstringmaxLength)\n *\n * @example\n *  match(value)\n *   .with(P.string.maxLength(10), () => 'string with more length <= 10')\n */\nconst maxLength = <const max extends number>(max: max) =>\n  when((value) => isString(value) && value.length <= max);\n\n/**\n * `P.string.includes(substr)` is a pattern, matching **strings** containing `substr`.\n *\n * [Read the documentation for `P.string.includes` on GitHub](https://github.com/gvergnaud/ts-pattern#Pstringincludes)\n *\n * @example\n *  match(value)\n *   .with(P.string.includes('http'), () => 'value contains http')\n */\nconst includes = <input, const substr extends string>(\n  substr: substr\n): GuardExcludeP<input, string, never> =>\n  when((value) => isString(value) && value.includes(substr));\n\n/**\n * `P.string.regex(expr)` is a pattern, matching **strings** that `expr` regular expression.\n *\n * [Read the documentation for `P.string.regex` on GitHub](https://github.com/gvergnaud/ts-pattern#Pstringregex)\n *\n * @example\n *  match(value)\n *   .with(P.string.regex(/^https?:\\/\\//), () => 'url')\n */\nconst regex = <input, const expr extends string | RegExp>(\n  expr: expr\n): GuardExcludeP<input, string, never> =>\n  when((value) => isString(value) && Boolean(value.match(expr)));\n\ntype MaybeAnd<omitted, input, p1, p2> = [omitted] extends [never]\n  ? p2\n  : AndP<input, [p1, p2]>;\n\ntype StringChainable<\n  p extends Matcher<any, any, any, any, any>,\n  omitted extends string = never\n> = Chainable<p, omitted> &\n  Omit<\n    {\n      /**\n       * `P.string.startsWith(start)` is a pattern, matching **strings** starting with `start`.\n       *\n       * [Read the documentation for `P.string.startsWith` on GitHub](https://github.com/gvergnaud/ts-pattern#PstringstartsWith)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.string.startsWith('A'), () => 'value starts with an A')\n       */\n      startsWith<input, const start extends string>(\n        start: start\n      ): StringChainable<\n        MaybeAnd<omitted, input, p, GuardP<input, `${start}${string}`>>,\n        omitted | 'startsWith'\n      >;\n      /**\n       * `P.string.endsWith(end)` is a pattern, matching **strings** ending with `end`.\n       *\n       * [Read the documentation for `P.string.endsWith` on GitHub](https://github.com/gvergnaud/ts-pattern#PstringendsWith)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.string.endsWith('!'), () => 'value ends with an !')\n       */\n      endsWith<input, const end extends string>(\n        end: end\n      ): StringChainable<\n        MaybeAnd<omitted, input, p, GuardP<input, `${string}${end}`>>,\n        omitted | 'endsWith'\n      >;\n      /**\n       * `P.string.minLength(min)` is a pattern, matching **strings** with at least `min` characters.\n       *\n       * [Read the documentation for `P.string.minLength` on GitHub](https://github.com/gvergnaud/ts-pattern#PstringminLength)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.string.minLength(10), () => 'string with more length <= 10')\n       */\n      minLength<input, const min extends number>(\n        min: min\n      ): StringChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, string, never>>,\n        omitted | 'minLength'\n      >;\n      /**\n       * `P.string.maxLength(max)` is a pattern, matching **strings** with at most `max` characters.\n       *\n       * [Read the documentation for `P.string.maxLength` on GitHub](https://github.com/gvergnaud/ts-pattern#PstringmaxLength)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.string.maxLength(10), () => 'string with more length >= 10')\n       */\n      maxLength<input, const max extends number>(\n        max: max\n      ): StringChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, string, never>>,\n        omitted | 'maxLength'\n      >;\n      /**\n       * `P.string.includes(substr)` is a pattern, matching **strings** containing `substr`.\n       *\n       * [Read the documentation for `P.string.includes` on GitHub](https://github.com/gvergnaud/ts-pattern#Pstringincludes)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.string.includes('http'), () => 'value contains http')\n       */\n      includes<input, const substr extends string>(\n        substr: substr\n      ): StringChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, string, never>>,\n        omitted\n      >;\n      /**\n       * `P.string.regex(expr)` is a pattern, matching **strings** that `expr` regular expression.\n       *\n       * [Read the documentation for `P.string.regex` on GitHub](https://github.com/gvergnaud/ts-pattern#Pstringregex)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.string.regex(/^https?:\\/\\//), () => 'url')\n       */\n      regex<input, const expr extends string | RegExp>(\n        expr: expr\n      ): StringChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, string, never>>,\n        omitted\n      >;\n    },\n    omitted\n  >;\n\nconst stringChainable = <p extends Matcher<any, any, any, any, any>>(\n  pattern: p\n): StringChainable<p> =>\n  Object.assign(chainable(pattern), {\n    startsWith: (str: string) =>\n      stringChainable(intersection(pattern, startsWith(str))),\n    endsWith: (str: string) =>\n      stringChainable(intersection(pattern, endsWith(str))),\n    minLength: (min: number) =>\n      stringChainable(intersection(pattern, minLength(min))),\n    maxLength: (max: number) =>\n      stringChainable(intersection(pattern, maxLength(max))),\n    includes: (str: string) =>\n      stringChainable(intersection(pattern, includes(str))),\n    regex: (str: string) => stringChainable(intersection(pattern, regex(str))),\n  }) as any;\n\n/**\n * `P.string` is a wildcard pattern, matching any **string**.\n *\n * [Read the documentation for `P.string` on GitHub](https://github.com/gvergnaud/ts-pattern#Pstring-wildcard)\n *\n * @example\n *  match(value)\n *   .with(P.string, () => 'will match on strings')\n */\nexport const string: StringPattern = stringChainable(when(isString));\n\n/**\n * `P.number.between(min, max)` matches **number** between `min` and `max`,\n * equal to min or equal to max.\n *\n * [Read the documentation for `P.number.between` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberbetween)\n *\n * @example\n *  match(value)\n *   .with(P.number.between(0, 10), () => '0 <= numbers <= 10')\n */\nexport const between = <\n  input,\n  const min extends number,\n  const max extends number\n>(\n  min: min,\n  max: max\n): GuardExcludeP<input, number, never> =>\n  when((value) => isNumber(value) && min <= value && max >= value);\n\n/**\n * `P.number.lt(max)` matches **number** smaller than `max`.\n *\n * [Read the documentation for `P.number.lt` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberlt)\n *\n * @example\n *  match(value)\n *   .with(P.number.lt(10), () => 'numbers < 10')\n */\nexport const lt = <input, const max extends number>(\n  max: max\n): GuardExcludeP<input, number, never> =>\n  when((value) => isNumber(value) && value < max);\n\n/**\n * `P.number.gt(min)` matches **number** greater than `min`.\n *\n * [Read the documentation for `P.number.gt` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumbergt)\n *\n * @example\n *  match(value)\n *   .with(P.number.gt(10), () => 'numbers > 10')\n */\nexport const gt = <input, const min extends number>(\n  min: min\n): GuardExcludeP<input, number, never> =>\n  when((value) => isNumber(value) && value > min);\n\n/**\n * `P.number.lte(max)` matches **number** smaller than or equal to `max`.\n *\n * [Read the documentation for `P.number.lte` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberlte)\n *\n * @example\n *  match(value)\n *   .with(P.number.lte(10), () => 'numbers <= 10')\n */\nexport const lte = <input, const max extends number>(\n  max: max\n): GuardExcludeP<input, number, never> =>\n  when((value) => isNumber(value) && value <= max);\n\n/**\n * `P.number.gte(min)` matches **number** greater than or equal to `min`.\n *\n * [Read the documentation for `P.number.gte` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumbergte)\n *\n * @example\n *  match(value)\n *   .with(P.number.gte(10), () => 'numbers >= 10')\n */\nexport const gte = <input, const min extends number>(\n  min: min\n): GuardExcludeP<input, number, never> =>\n  when((value) => isNumber(value) && value >= min);\n\n/**\n * `P.number.int` matches **integer** numbers.\n *\n * [Read the documentation for `P.number.int` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberint)\n *\n * @example\n *  match(value)\n *   .with(P.number.int, () => 'an integer')\n */\nexport const int = <input>(): GuardExcludeP<input, number, never> =>\n  when((value) => isNumber(value) && Number.isInteger(value));\n\n/**\n * `P.number.finite` matches **finite numbers**.\n *\n * [Read the documentation for `P.number.finite` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberfinite)\n *\n * @example\n *  match(value)\n *   .with(P.number.finite, () => 'not Infinity')\n */\nexport const finite = <input>(): GuardExcludeP<input, number, never> =>\n  when((value) => isNumber(value) && Number.isFinite(value));\n\n/**\n * `P.number.positive` matches **positive** numbers.\n *\n * [Read the documentation for `P.number.positive` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberpositive)\n *\n * @example\n *  match(value)\n *   .with(P.number.positive, () => 'number > 0')\n */\nexport const positive = <input>(): GuardExcludeP<input, number, never> =>\n  when((value) => isNumber(value) && value > 0);\n\n/**\n * `P.number.negative` matches **negative** numbers.\n *\n * [Read the documentation for `P.number.negative` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumbernegative)\n *\n * @example\n *  match(value)\n *   .with(P.number.negative, () => 'number < 0')\n */\nexport const negative = <input>(): GuardExcludeP<input, number, never> =>\n  when((value) => isNumber(value) && value < 0);\n\ntype NumberChainable<p, omitted extends string = never> = Chainable<\n  p,\n  omitted\n> &\n  Omit<\n    {\n      /**\n       * `P.number.between(min, max)` matches **number** between `min` and `max`,\n       * equal to min or equal to max.\n       *\n       * [Read the documentation for `P.number.between` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberbetween)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.number.between(0, 10), () => '0 <= numbers <= 10')\n       */\n      between<input, const min extends number, const max extends number>(\n        min: min,\n        max: max\n      ): NumberChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, number, never>>,\n        omitted\n      >;\n      /**\n       * `P.number.lt(max)` matches **number** smaller than `max`.\n       *\n       * [Read the documentation for `P.number.lt` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberlt)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.number.lt(10), () => 'numbers < 10')\n       */\n      lt<input, const max extends number>(\n        max: max\n      ): NumberChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, number, never>>,\n        omitted\n      >;\n      /**\n       * `P.number.gt(min)` matches **number** greater than `min`.\n       *\n       * [Read the documentation for `P.number.gt` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumbergt)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.number.gt(10), () => 'numbers > 10')\n       */\n      gt<input, const min extends number>(\n        min: min\n      ): NumberChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, number, never>>,\n        omitted\n      >;\n      /**\n       * `P.number.lte(max)` matches **number** smaller than or equal to `max`.\n       *\n       * [Read the documentation for `P.number.lte` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberlte)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.number.lte(10), () => 'numbers <= 10')\n       */\n      lte<input, const max extends number>(\n        max: max\n      ): NumberChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, number, never>>,\n        omitted\n      >;\n      /**\n       * `P.number.gte(min)` matches **number** greater than or equal to `min`.\n       *\n       * [Read the documentation for `P.number.gte` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumbergte)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.number.gte(10), () => 'numbers >= 10')\n       */\n      gte<input, const min extends number>(\n        min: min\n      ): NumberChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, number, never>>,\n        omitted\n      >;\n      /**\n       * `P.number.int` matches **integer** numbers.\n       *\n       * [Read the documentation for `P.number.int` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberint)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.number.int, () => 'an integer')\n       */\n      int<input>(): NumberChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, number, never>>,\n        omitted | 'int'\n      >;\n      /**\n       * `P.number.finite` matches **finite numbers**.\n       *\n       * [Read the documentation for `P.number.finite` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberfinite)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.number.finite, () => 'not Infinity')\n       */\n      finite<input>(): NumberChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, number, never>>,\n        omitted | 'finite'\n      >;\n      /**\n       * `P.number.positive` matches **positive** numbers.\n       *\n       * [Read the documentation for `P.number.positive` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberpositive)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.number.positive, () => 'number > 0')\n       */\n      positive<input>(): NumberChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, number, never>>,\n        omitted | 'positive' | 'negative'\n      >;\n      /**\n       * `P.number.negative` matches **negative** numbers.\n       *\n       * [Read the documentation for `P.number.negative` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumbernegative)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.number.negative, () => 'number < 0')\n       */\n      negative<input>(): NumberChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, number, never>>,\n        omitted | 'positive' | 'negative' | 'negative'\n      >;\n    },\n    omitted\n  >;\n\nconst numberChainable = <p extends Matcher<any, any, any, any, any>>(\n  pattern: p\n): NumberChainable<p> =>\n  Object.assign(chainable(pattern), {\n    between: (min: number, max: number) =>\n      numberChainable(intersection(pattern, between(min, max))),\n    lt: (max: number) => numberChainable(intersection(pattern, lt(max))),\n    gt: (min: number) => numberChainable(intersection(pattern, gt(min))),\n    lte: (max: number) => numberChainable(intersection(pattern, lte(max))),\n    gte: (min: number) => numberChainable(intersection(pattern, gte(min))),\n    int: () => numberChainable(intersection(pattern, int())),\n    finite: () => numberChainable(intersection(pattern, finite())),\n    positive: () => numberChainable(intersection(pattern, positive())),\n    negative: () => numberChainable(intersection(pattern, negative())),\n  }) as any;\n\n/**\n * `P.number` is a wildcard pattern, matching any **number**.\n *\n * [Read the documentation for `P.number` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumber-wildcard)\n *\n * @example\n *  match(value)\n *   .with(P.number, () => 'will match on numbers')\n */\nexport const number: NumberPattern = numberChainable(when(isNumber));\n\n/**\n * `P.bigint.between(min, max)` matches **bigint** between `min` and `max`,\n * equal to min or equal to max.\n *\n * [Read the documentation for `P.bigint.between` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberbetween)\n *\n * @example\n *  match(value)\n *   .with(P.bigint.between(0, 10), () => '0 <= numbers <= 10')\n */\nexport const betweenBigInt = <\n  input,\n  const min extends bigint,\n  const max extends bigint\n>(\n  min: min,\n  max: max\n): GuardExcludeP<input, bigint, never> =>\n  when((value) => isBigInt(value) && min <= value && max >= value);\n\n/**\n * `P.bigint.lt(max)` matches **bigint** smaller than `max`.\n *\n * [Read the documentation for `P.bigint.lt` on GitHub](https://github.com/gvergnaud/ts-pattern#bigintlt)\n *\n * @example\n *  match(value)\n *   .with(P.bigint.lt(10), () => 'numbers < 10')\n */\nexport const ltBigInt = <input, const max extends bigint>(\n  max: max\n): GuardExcludeP<input, bigint, never> =>\n  when((value) => isBigInt(value) && value < max);\n\n/**\n * `P.bigint.gt(min)` matches **bigint** greater than `min`.\n *\n * [Read the documentation for `P.bigint.gt` on GitHub](https://github.com/gvergnaud/ts-pattern#bigintgt)\n *\n * @example\n *  match(value)\n *   .with(P.bigint.gt(10), () => 'numbers > 10')\n */\nexport const gtBigInt = <input, const min extends bigint>(\n  min: min\n): GuardExcludeP<input, bigint, never> =>\n  when((value) => isBigInt(value) && value > min);\n\n/**\n * `P.bigint.lte(max)` matches **bigint** smaller than or equal to `max`.\n *\n * [Read the documentation for `P.bigint.lte` on GitHub](https://github.com/gvergnaud/ts-pattern#bigintlte)\n *\n * @example\n *  match(value)\n *   .with(P.bigint.lte(10), () => 'bigints <= 10')\n */\nexport const lteBigInt = <input, const max extends bigint>(\n  max: max\n): GuardExcludeP<input, bigint, never> =>\n  when((value) => isBigInt(value) && value <= max);\n\n/**\n * `P.bigint.gte(min)` matches **bigint** greater than or equal to `min`.\n *\n * [Read the documentation for `P.bigint.gte` on GitHub](https://github.com/gvergnaud/ts-pattern#Pbigintgte)\n *\n * @example\n *  match(value)\n *   .with(P.bigint.gte(10), () => 'bigints >= 10')\n */\nexport const gteBigInt = <input, const min extends bigint>(\n  min: min\n): GuardExcludeP<input, bigint, never> =>\n  when((value) => isBigInt(value) && value >= min);\n\n/**\n * `P.bigint.positive` matches **positive** bigints.\n *\n * [Read the documentation for `P.bigint.positive` on GitHub](https://github.com/gvergnaud/ts-pattern#Pbigintpositive)\n *\n * @example\n *  match(value)\n *   .with(P.bigint.positive, () => 'bigint > 0')\n */\nexport const positiveBigInt = <input>(): GuardExcludeP<input, bigint, never> =>\n  when((value) => isBigInt(value) && value > 0);\n\n/**\n * `P.bigint.negative` matches **negative** bigints.\n *\n * [Read the documentation for `P.bigint.negative` on GitHub](https://github.com/gvergnaud/ts-pattern#Pbigintnegative)\n *\n * @example\n *  match(value)\n *   .with(P.bigint.negative, () => 'bigint < 0')\n */\nexport const negativeBigInt = <input>(): GuardExcludeP<input, bigint, never> =>\n  when((value) => isBigInt(value) && value < 0);\n\ntype BigIntChainable<p, omitted extends string = never> = Chainable<\n  p,\n  omitted\n> &\n  Omit<\n    {\n      /**\n       * `P.bigint.between(min, max)` matches **bigint** between `min` and `max`,\n       * equal to min or equal to max.\n       *\n       * [Read the documentation for `P.bigint.between` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberbetween)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.bigint.between(0, 10), () => '0 <= numbers <= 10')\n       */\n      between<input, const min extends bigint, const max extends bigint>(\n        min: min,\n        max: max\n      ): BigIntChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, bigint, never>>,\n        omitted\n      >;\n      /**\n       * `P.bigint.lt(max)` matches **bigint** smaller than `max`.\n       *\n       * [Read the documentation for `P.bigint.lt` on GitHub](https://github.com/gvergnaud/ts-pattern#bigintlt)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.bigint.lt(10), () => 'numbers < 10')\n       */\n      lt<input, const max extends bigint>(\n        max: max\n      ): BigIntChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, bigint, never>>,\n        omitted\n      >;\n      /**\n       * `P.bigint.gt(min)` matches **bigint** greater than `min`.\n       *\n       * [Read the documentation for `P.bigint.gt` on GitHub](https://github.com/gvergnaud/ts-pattern#bigintgt)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.bigint.gt(10), () => 'numbers > 10')\n       */\n      gt<input, const min extends bigint>(\n        min: min\n      ): BigIntChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, bigint, never>>,\n        omitted\n      >;\n      /**\n       * `P.bigint.lte(max)` matches **bigint** smaller than or equal to `max`.\n       *\n       * [Read the documentation for `P.bigint.lte` on GitHub](https://github.com/gvergnaud/ts-pattern#bigintlte)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.bigint.lte(10), () => 'bigints <= 10')\n       */\n      lte<input, const max extends bigint>(\n        max: max\n      ): BigIntChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, bigint, never>>,\n        omitted\n      >;\n      /**\n       * `P.bigint.gte(min)` matches **bigint** greater than or equal to `min`.\n       *\n       * [Read the documentation for `P.bigint.gte` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumbergte)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.bigint.gte(10), () => 'bigints >= 10')\n       */\n      gte<input, const min extends bigint>(\n        min: min\n      ): BigIntChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, bigint, never>>,\n        omitted\n      >;\n      /**\n       * `P.bigint.positive` matches **positive** bigints.\n       *\n       * [Read the documentation for `P.bigint.positive` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumberpositive)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.bigint.positive, () => 'bigint > 0')\n       */\n      positive<input>(): BigIntChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, bigint, never>>,\n        omitted | 'positive' | 'negative'\n      >;\n      /**\n       * `P.bigint.negative` matches **negative** bigints.\n       *\n       * [Read the documentation for `P.bigint.negative` on GitHub](https://github.com/gvergnaud/ts-pattern#Pnumbernegative)\n       *\n       * @example\n       *  match(value)\n       *   .with(P.bigint.negative, () => 'bigint < 0')\n       */\n      negative<input>(): BigIntChainable<\n        MaybeAnd<omitted, input, p, GuardExcludeP<input, bigint, never>>,\n        omitted | 'positive' | 'negative' | 'negative'\n      >;\n    },\n    omitted\n  >;\n\nconst bigintChainable = <p extends Matcher<any, any, any, any, any>>(\n  pattern: p\n): BigIntChainable<p> =>\n  Object.assign(chainable(pattern), {\n    between: (min: bigint, max: bigint) =>\n      bigintChainable(intersection(pattern, betweenBigInt(min, max))),\n    lt: (max: bigint) => bigintChainable(intersection(pattern, ltBigInt(max))),\n    gt: (min: bigint) => bigintChainable(intersection(pattern, gtBigInt(min))),\n    lte: (max: bigint) =>\n      bigintChainable(intersection(pattern, lteBigInt(max))),\n    gte: (min: bigint) =>\n      bigintChainable(intersection(pattern, gteBigInt(min))),\n    positive: () => bigintChainable(intersection(pattern, positiveBigInt())),\n    negative: () => bigintChainable(intersection(pattern, negativeBigInt())),\n  }) as any;\n\n/**\n * `P.bigint` is a wildcard pattern, matching any **bigint**.\n *\n * [Read the documentation for `P.bigint` on GitHub](https://github.com/gvergnaud/ts-pattern#bigint-wildcard)\n *\n * @example\n *   .with(P.bigint, () => 'will match on bigints')\n */\nexport const bigint: BigIntPattern = bigintChainable(when(isBigInt));\n\n/**\n * `P.boolean` is a wildcard pattern, matching any **boolean**.\n *\n * [Read the documentation for `P.boolean` on GitHub](https://github.com/gvergnaud/ts-pattern#boolean-wildcard)\n *\n * @example\n *   .with(P.boolean, () => 'will match on booleans')\n */\nexport const boolean: BooleanPattern = chainable(when(isBoolean));\n\n/**\n * `P.symbol` is a wildcard pattern, matching any **symbol**.\n *\n * [Read the documentation for `P.symbol` on GitHub](https://github.com/gvergnaud/ts-pattern#symbol-wildcard)\n *\n * @example\n *   .with(P.symbol, () => 'will match on symbols')\n */\nexport const symbol: SymbolPattern = chainable(when(isSymbol));\n\n/**\n * `P.nullish` is a wildcard pattern, matching **null** or **undefined**.\n *\n * [Read the documentation for `P.nullish` on GitHub](https://github.com/gvergnaud/ts-pattern#nullish-wildcard)\n *\n * @example\n *   .with(P.nullish, () => 'will match on null or undefined')\n */\nexport const nullish: NullishPattern = chainable(when(isNullish));\n\n/**\n * `P.instanceOf(SomeClass)` is a pattern matching instances of a given class.\n *\n * [Read the documentation for `P.instanceOf` on GitHub](https://github.com/gvergnaud/ts-pattern#Pinstanceof-patterns)\n *\n *  @example\n *   .with(P.instanceOf(SomeClass), () => 'will match on SomeClass instances')\n */\nexport function instanceOf<T extends AnyConstructor>(\n  classConstructor: T\n): Chainable<GuardP<unknown, InstanceType<T>>> {\n  return chainable(when(isInstanceOf(classConstructor)));\n}\n\n/**\n * `P.shape(somePattern)` lets you call methods like `.optional()`, `.and`, `.or` and `.select()`\n * On structural patterns, like objects and arrays.\n *\n * [Read the documentation for `P.shape` on GitHub](https://github.com/gvergnaud/ts-pattern#Pshape-patterns)\n *\n *  @example\n *   .with(\n *     {\n *       state: P.shape({ status: \"success\" }).optional().select()\n *     },\n *     (state) => 'match the success state, or undefined.'\n *   )\n */\nexport function shape<input, const p extends Pattern<input>>(\n  pattern: p\n): Chainable<GuardP<input, InvertPattern<p, input>>>;\nexport function shape(pattern: UnknownPattern) {\n  return chainable(when(isMatching(pattern)));\n}\n","import { Pattern } from './types/Pattern';\nimport { Match } from './types/Match';\nimport * as symbols from './internals/symbols';\nimport { matchPattern } from './internals/helpers';\n\n/**\n * `match` creates a **pattern matching expression**.\n *  * Use `.with(pattern, handler)` to pattern match on the input.\n *  * Use `.exhaustive()` or `.otherwise(() => defaultValue)` to end the expression and get the result.\n *\n * [Read the documentation for `match` on GitHub](https://github.com/gvergnaud/ts-pattern#match)\n *\n * @example\n *  declare let input: \"A\" | \"B\";\n *\n *  return match(input)\n *    .with(\"A\", () => \"It's a A!\")\n *    .with(\"B\", () => \"It's a B!\")\n *    .exhaustive();\n *\n */\nexport function match<const input, output = symbols.unset>(\n  value: input\n): Match<input, output> {\n  return new MatchExpression(value) as any;\n}\n\ntype MatchState<output> =\n  | { matched: true; value: output }\n  | { matched: false; value: undefined };\n\nconst unmatched: MatchState<never> = {\n  matched: false,\n  value: undefined,\n};\n\n/**\n * This class represents a match expression. It follows the\n * builder pattern, we chain methods to add features to the expression\n * until we call `.exhaustive`, `.otherwise` or the unsafe `.run`\n * method to execute it.\n *\n * The types of this class aren't public, the public type definition\n * can be found in src/types/Match.ts.\n */\nclass MatchExpression<input, output> {\n  constructor(\n    private input: input,\n    private state: MatchState<output> = unmatched\n  ) {}\n\n  with(...args: any[]): MatchExpression<input, output> {\n    if (this.state.matched) return this;\n\n    const handler: (selection: unknown, value: input) => output =\n      args[args.length - 1];\n\n    const patterns: Pattern<input>[] = [args[0]];\n    const predicates: ((value: input) => unknown)[] = [];\n\n    // case with guard as second argument\n    if (args.length === 3 && typeof args[1] === 'function') {\n      patterns.push(args[0]);\n      predicates.push(args[1]);\n    } else if (args.length > 2) {\n      // case with several patterns\n      patterns.push(...args.slice(1, args.length - 1));\n    }\n\n    let selected: Record<string, unknown> = {};\n\n    const matched = Boolean(\n      patterns.some((pattern) =>\n        matchPattern(pattern, this.input, (key, value) => {\n          selected[key] = value;\n        })\n      ) && predicates.every((predicate) => predicate(this.input))\n    );\n\n    const state = matched\n      ? {\n          matched: true as const,\n          value: handler(\n            Object.keys(selected).length\n              ? symbols.anonymousSelectKey in selected\n                ? selected[symbols.anonymousSelectKey]\n                : selected\n              : this.input,\n            this.input\n          ),\n        }\n      : unmatched;\n\n    return new MatchExpression(this.input, state);\n  }\n\n  when(\n    predicate: (value: input) => unknown,\n    handler: (selection: input, value: input) => output\n  ): MatchExpression<input, output> {\n    if (this.state.matched) return this;\n\n    const matched = Boolean(predicate(this.input));\n\n    return new MatchExpression<input, output>(\n      this.input,\n      matched\n        ? { matched: true, value: handler(this.input, this.input) }\n        : unmatched\n    );\n  }\n\n  otherwise(handler: (value: input) => output): output {\n    if (this.state.matched) return this.state.value;\n    return handler(this.input);\n  }\n\n  exhaustive(): output {\n    return this.run();\n  }\n\n  run(): output {\n    if (this.state.matched) return this.state.value;\n\n    let displayedValue;\n    try {\n      displayedValue = JSON.stringify(this.input);\n    } catch (e) {\n      displayedValue = this.input;\n    }\n\n    throw new Error(\n      `Pattern matching error: no pattern matches value ${displayedValue}`\n    );\n  }\n\n  returnType() {\n    return this;\n  }\n}\n"],"names":["matcher","Symbol","isVariadic","anonymousSelectKey","isObject","value","Boolean","isMatcher","x","symbols","matchPattern","pattern","select","_matcher$match","match","matched","selections","Object","keys","forEach","key","Array","isArray","_step","startPatterns","endPatterns","variadicPatterns","_iterator","_createForOfIteratorHelperLoose","done","subpattern","push","length","Error","startValues","slice","endValues","middleValues","Infinity","every","subPattern","i","k","matcherType","is","getSelectionKeys","_pattern$symbols$matc","_pattern$symbols$matc2","_pattern$symbols$matc3","call","flatMap","values","xs","f","reduce","acc","p","concat","isMatching","args","arguments","chainable","assign","optional","and","p2","intersection","or","union","undefined","arrayChainable","_Object$assign2","iterator","regeneratorRuntime","mark","_callee","_Object$assign","wrap","_context","prev","next","stop","variadic","_chainable","selector","setEvery","set","predicate","mapEvery","map","_step2","_iterator2","entries","_step2$value","_chainable4","patterns","_chainable5","some","when","_ref","_chainable7","_selections","isNumber","isString","isBigInt","any","_","string","stringChainable","startsWith","str","start","endsWith","end","minLength","min","maxLength","max","includes","substr","regex","expr","between","lt","gt","lte","gte","int","Number","isInteger","finite","isFinite","positive","negative","number","numberChainable","betweenBigInt","ltBigInt","gtBigInt","lteBigInt","gteBigInt","positiveBigInt","negativeBigInt","bigint","bigintChainable","boolean","symbol","nullish","_arrayChainable","v","_chainable2","Set","size","_chainable3","Map","_args$","toString","patternKey","patternValue","keyMatch","valueMatch","_chainable6","classConstructor","val","isInstanceOf","unmatched","MatchExpression","input","state","this","_proto","prototype","_this","handler","predicates","apply","selected","otherwise","exhaustive","run","displayedValue","JSON","stringify","e","returnType"],"mappings":"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"}