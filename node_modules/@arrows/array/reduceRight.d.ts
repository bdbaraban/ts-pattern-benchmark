declare type ReducingFirstFn<V> = (accumulator: V, currentValue: V, index?: number, arr?: V[]) => V;
declare type _ReduceRightFirst = <T>(reducingFn: ReducingFirstFn<T>, arr: T[]) => T;
declare type _ReduceRightFirst2 = <T>(reducingFn: ReducingFirstFn<T>) => (arr: T[]) => T;
declare type ReduceRightFirst = _ReduceRightFirst & _ReduceRightFirst2;
declare type ReducingFn<V, A> = (accumulator: A, currentValue: V, index?: number, arr?: V[]) => A;
declare type Curry1<T, X> = (arr: T[]) => X;
declare type Curry2<T, X> = {
    (initialValue: X): Curry1<T, X>;
    (initialValue: X, arr: T[]): X;
};
declare type Curry3 = {
    <T, X>(reducingFn: ReducingFn<T, X>): Curry2<T, X>;
    <T, X>(reducingFn: ReducingFn<T, X>, initialValue: X): Curry1<T, X>;
};
declare type _ReduceRight = <T, X>(reducingFn: ReducingFn<T, X>, initialValue: X, arr: T[]) => X;
declare type CurriedReduceRight = _ReduceRight & Curry3;
declare type ReduceRight = CurriedReduceRight & {
    first: ReduceRightFirst;
};
/**
 * Functional wrapper for Array.prototype.reduceRight
 *
 * Calls the specified callback function for all the elements in an array,
 * in descending order.
 * The return value of the reducing function is the accumulated result,
 * and is provided as an argument in the next call to the reducing function.
 *
 * @param reducingFn Reducing function
 * @param initialValue Initial value of the accumulator
 * @param arr Initial array
 * @returns Final accumulator value
 *
 * @method first Reduce without initializer
 */
declare const reduceRight: ReduceRight;
export { reduceRight };
export default reduceRight;
