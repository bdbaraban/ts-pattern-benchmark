declare type ZippingAllFn<T, V, X> = (otherArrItem: V | undefined, arrItem: T | undefined) => X;
declare type CurryAll1<T, X> = (arr: T[]) => X[];
declare type CurryAll2<T, V, X> = {
    (otherArr: V[]): CurryAll1<T, X>;
    (otherArr: V[], arr: T[]): X[];
};
declare type CurryAll3 = {
    <T, V, X>(zippingFn: ZippingAllFn<T, V, X>): CurryAll2<T, V, X>;
    <T, V, X>(zippingFn: ZippingAllFn<T, V, X>, otherArr: V[]): CurryAll1<T, X>;
};
declare type _ZipAllWith_ = <T, V, X>(zippingFn: ZippingAllFn<T, V, X>, otherArr: V[], arr: T[]) => X[];
declare type ZipAllWith_ = _ZipAllWith_ & CurryAll3;
declare type ZippingFn<T, V, X> = (otherArrItem: V, arrItem: T) => X;
declare type Curry1<T, X> = (arr: T[]) => X[];
declare type Curry2<T, V, X> = {
    (otherArr: V[]): Curry1<T, X>;
    (otherArr: V[], arr: T[]): X[];
};
declare type Curry3 = {
    <T, V, X>(zippingFn: ZippingFn<T, V, X>): Curry2<T, V, X>;
    <T, V, X>(zippingFn: ZippingFn<T, V, X>, otherArr: V[]): Curry1<T, X>;
};
declare type _ZipWith_ = <T, V, X>(zippingFn: ZippingFn<T, V, X>, otherArr: V[], arr: T[]) => X[];
declare type CurriedZipWith_ = _ZipWith_ & Curry3;
declare type ZipWith_ = CurriedZipWith_ & {
    all: ZipAllWith_;
};
/**
 * Zips two arrays producing new values with a zipping function,
 * that takes elements with the same indexes.
 * Zips until the length of the shorter array is reached.
 *
 * @param zippingFn Zipping function
 * @param otherArr Array that you want to zip with initial array
 * @param arr Initial array
 * @returns New, zipped array
 *
 * @method all Zips until the length of the longer array is reached
 */
declare const zipWith_: ZipWith_;
export { zipWith_ };
export default zipWith_;
