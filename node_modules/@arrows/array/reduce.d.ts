declare type ReducingFirstFn<V> = (accumulator: V, currentValue: V, index?: number, arr?: V[]) => V;
declare type _ReduceFirst = <T>(reducingFn: ReducingFirstFn<T>, arr: T[]) => T;
declare type _ReduceFirst2 = <T>(reducingFn: ReducingFirstFn<T>) => (arr: T[]) => T;
declare type ReduceFirst = _ReduceFirst & _ReduceFirst2;
declare type ReducingFn<V, A> = (accumulator: A, currentValue: V, index?: number, arr?: V[]) => A;
declare type Curry1<T, X> = (arr: T[]) => X;
declare type Curry2<T, X> = {
    (initialValue: X): Curry1<T, X>;
    (initialValue: X, arr: T[]): X;
};
declare type Curry3 = {
    <T, X>(reducingFn: ReducingFn<T, X>): Curry2<T, X>;
    <T, X>(reducingFn: ReducingFn<T, X>, initialValue: X): Curry1<T, X>;
};
declare type _Reduce = <T, X>(reducingFn: ReducingFn<T, X>, initialValue: X, arr: T[]) => X;
declare type CurriedReduce = _Reduce & Curry3;
declare type Reduce = CurriedReduce & {
    first: ReduceFirst;
};
/**
 * Functional wrapper for Array.prototype.reduce
 *
 * Calls the specified reducing function for all the elements in an array.
 * The return value of the reducing function is the accumulated result,
 * and is provided as an argument in the next call to the reducing function.
 *
 * @param reducingFn Reducing function
 * @param initialValue Initial value of the accumulator
 * @param arr Initial array
 * @returns Final accumulator value
 *
 * @method first Reduce without initializer
 */
declare const reduce: Reduce;
export { reduce };
export default reduce;
