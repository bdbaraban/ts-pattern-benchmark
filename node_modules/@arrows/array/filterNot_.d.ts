declare type FilteringFn<V> = (element: V, index: number, arr: V[]) => boolean;
declare type _FilterNot_ = <T>(fn: FilteringFn<T>, arr: T[]) => T[];
declare type _FilterNot2_ = <T>(fn: FilteringFn<T>) => (arr: T[]) => T[];
declare type FilterNot_ = _FilterNot_ & _FilterNot2_;
/**
 * Creates a new array from the initial one, without the values
 * that meet the condition specified in a filtering function.
 *
 * It is useful when you have a ready-to-use filtering function,
 * that you want to pass as an argument, otherwise you would have
 * to manually wrap it in a function to negate its results.
 *
 * @param fn Filtering function
 * @param arr initial array
 * @returns New array
 */
declare const filterNot_: FilterNot_;
export { filterNot_ };
export default filterNot_;
